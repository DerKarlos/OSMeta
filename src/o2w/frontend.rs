// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `frontend_v06.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

///  a block containing all three-dimensional vectors used in the tile.
///  Vectors are referenced via their position in this block.
///  Values are in millimeters relative to the center of the tile.
///  The first 3 values are x, y, and z coordinates of the first vector, etc.
///  Therefore, the number of coordinates must be divisible by 3. 
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:frontend_pbf.Vector3dBlock)
pub struct Vector3dBlock {
    // message fields
    // @@protoc_insertion_point(field:frontend_pbf.Vector3dBlock.coords)
    pub coords: ::std::vec::Vec<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:frontend_pbf.Vector3dBlock.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Vector3dBlock {
    fn default() -> &'a Vector3dBlock {
        <Vector3dBlock as ::protobuf::Message>::default_instance()
    }
}

impl Vector3dBlock {
    pub fn new() -> Vector3dBlock {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "coords",
            |m: &Vector3dBlock| { &m.coords },
            |m: &mut Vector3dBlock| { &mut m.coords },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Vector3dBlock>(
            "Vector3dBlock",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Vector3dBlock {
    const NAME: &'static str = "Vector3dBlock";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_sint64_into(&mut self.coords)?;
                },
                8 => {
                    self.coords.push(is.read_sint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::vec_packed_sint64_size(1, &self.coords);
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_repeated_packed_sint64(1, &self.coords)?;
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Vector3dBlock {
        Vector3dBlock::new()
    }

    fn clear(&mut self) {
        self.coords.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Vector3dBlock {
        static instance: Vector3dBlock = Vector3dBlock {
            coords: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Vector3dBlock {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Vector3dBlock").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Vector3dBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Vector3dBlock {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  a block containing all two-dimensional vectors used in the tile.
///  See Vector3dBlock for more details.
///  All values are multiplied with 1000. 
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:frontend_pbf.Vector2dBlock)
pub struct Vector2dBlock {
    // message fields
    // @@protoc_insertion_point(field:frontend_pbf.Vector2dBlock.coords)
    pub coords: ::std::vec::Vec<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:frontend_pbf.Vector2dBlock.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Vector2dBlock {
    fn default() -> &'a Vector2dBlock {
        <Vector2dBlock as ::protobuf::Message>::default_instance()
    }
}

impl Vector2dBlock {
    pub fn new() -> Vector2dBlock {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "coords",
            |m: &Vector2dBlock| { &m.coords },
            |m: &mut Vector2dBlock| { &mut m.coords },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Vector2dBlock>(
            "Vector2dBlock",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Vector2dBlock {
    const NAME: &'static str = "Vector2dBlock";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_sint64_into(&mut self.coords)?;
                },
                8 => {
                    self.coords.push(is.read_sint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::vec_packed_sint64_size(1, &self.coords);
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_repeated_packed_sint64(1, &self.coords)?;
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Vector2dBlock {
        Vector2dBlock::new()
    }

    fn clear(&mut self) {
        self.coords.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Vector2dBlock {
        static instance: Vector2dBlock = Vector2dBlock {
            coords: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Vector2dBlock {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Vector2dBlock").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Vector2dBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Vector2dBlock {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  a block containing strings referenced elsewhere in the tile. 
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:frontend_pbf.StringBlock)
pub struct StringBlock {
    // message fields
    // @@protoc_insertion_point(field:frontend_pbf.StringBlock.strings)
    pub strings: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:frontend_pbf.StringBlock.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StringBlock {
    fn default() -> &'a StringBlock {
        <StringBlock as ::protobuf::Message>::default_instance()
    }
}

impl StringBlock {
    pub fn new() -> StringBlock {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "strings",
            |m: &StringBlock| { &m.strings },
            |m: &mut StringBlock| { &mut m.strings },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StringBlock>(
            "StringBlock",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StringBlock {
    const NAME: &'static str = "StringBlock";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.strings.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.strings {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.strings {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StringBlock {
        StringBlock::new()
    }

    fn clear(&mut self) {
        self.strings.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StringBlock {
        static instance: StringBlock = StringBlock {
            strings: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StringBlock {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StringBlock").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StringBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StringBlock {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  a block containing all 2d shapes used in the tile. 
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:frontend_pbf.ShapeBlock)
pub struct ShapeBlock {
    // message fields
    // @@protoc_insertion_point(field:frontend_pbf.ShapeBlock.shapes)
    pub shapes: ::std::vec::Vec<Shape>,
    // special fields
    // @@protoc_insertion_point(special_field:frontend_pbf.ShapeBlock.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ShapeBlock {
    fn default() -> &'a ShapeBlock {
        <ShapeBlock as ::protobuf::Message>::default_instance()
    }
}

impl ShapeBlock {
    pub fn new() -> ShapeBlock {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "shapes",
            |m: &ShapeBlock| { &m.shapes },
            |m: &mut ShapeBlock| { &mut m.shapes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ShapeBlock>(
            "ShapeBlock",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ShapeBlock {
    const NAME: &'static str = "ShapeBlock";

    fn is_initialized(&self) -> bool {
        for v in &self.shapes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.shapes.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.shapes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.shapes {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ShapeBlock {
        ShapeBlock::new()
    }

    fn clear(&mut self) {
        self.shapes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ShapeBlock {
        static instance: ShapeBlock = ShapeBlock {
            shapes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ShapeBlock {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ShapeBlock").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ShapeBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ShapeBlock {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  a 2d shape 
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:frontend_pbf.Shape)
pub struct Shape {
    // message fields
    // @@protoc_insertion_point(field:frontend_pbf.Shape.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<shape::ShapeType>>,
    ///  parameters for the shape, such as the radius of a circle.
    /// The precise meaning depends on the shape type! 
    // @@protoc_insertion_point(field:frontend_pbf.Shape.parameters)
    pub parameters: ::std::vec::Vec<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:frontend_pbf.Shape.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Shape {
    fn default() -> &'a Shape {
        <Shape as ::protobuf::Message>::default_instance()
    }
}

impl Shape {
    pub fn new() -> Shape {
        ::std::default::Default::default()
    }

    // required .frontend_pbf.Shape.ShapeType type = 1;

    pub fn type_(&self) -> shape::ShapeType {
        match self.type_ {
            Some(e) => e.enum_value_or(shape::ShapeType::CIRCLE),
            None => shape::ShapeType::CIRCLE,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: shape::ShapeType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &Shape| { &m.type_ },
            |m: &mut Shape| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "parameters",
            |m: &Shape| { &m.parameters },
            |m: &mut Shape| { &mut m.parameters },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Shape>(
            "Shape",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Shape {
    const NAME: &'static str = "Shape";

    fn is_initialized(&self) -> bool {
        if self.type_.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    is.read_repeated_packed_sint64_into(&mut self.parameters)?;
                },
                16 => {
                    self.parameters.push(is.read_sint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::vec_packed_sint64_size(2, &self.parameters);
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_repeated_packed_sint64(2, &self.parameters)?;
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Shape {
        Shape::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.parameters.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Shape {
        static instance: Shape = Shape {
            type_: ::std::option::Option::None,
            parameters: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Shape {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Shape").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Shape {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Shape {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Shape`
pub mod shape {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:frontend_pbf.Shape.ShapeType)
    pub enum ShapeType {
        // @@protoc_insertion_point(enum_value:frontend_pbf.Shape.ShapeType.CIRCLE)
        CIRCLE = 1,
        // @@protoc_insertion_point(enum_value:frontend_pbf.Shape.ShapeType.POLYGON)
        POLYGON = 2,
        // @@protoc_insertion_point(enum_value:frontend_pbf.Shape.ShapeType.POLYLINE)
        POLYLINE = 3,
    }

    impl ::protobuf::Enum for ShapeType {
        const NAME: &'static str = "ShapeType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ShapeType> {
            match value {
                1 => ::std::option::Option::Some(ShapeType::CIRCLE),
                2 => ::std::option::Option::Some(ShapeType::POLYGON),
                3 => ::std::option::Option::Some(ShapeType::POLYLINE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ShapeType] = &[
            ShapeType::CIRCLE,
            ShapeType::POLYGON,
            ShapeType::POLYLINE,
        ];
    }

    impl ::protobuf::EnumFull for ShapeType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Shape.ShapeType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                ShapeType::CIRCLE => 0,
                ShapeType::POLYGON => 1,
                ShapeType::POLYLINE => 2,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for ShapeType {
        fn default() -> Self {
            ShapeType::CIRCLE
        }
    }

    impl ShapeType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ShapeType>("Shape.ShapeType")
        }
    }
}

///  a block containing all materials used in the tile. 
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:frontend_pbf.MaterialBlock)
pub struct MaterialBlock {
    // message fields
    // @@protoc_insertion_point(field:frontend_pbf.MaterialBlock.materials)
    pub materials: ::std::vec::Vec<Material>,
    // special fields
    // @@protoc_insertion_point(special_field:frontend_pbf.MaterialBlock.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MaterialBlock {
    fn default() -> &'a MaterialBlock {
        <MaterialBlock as ::protobuf::Message>::default_instance()
    }
}

impl MaterialBlock {
    pub fn new() -> MaterialBlock {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "materials",
            |m: &MaterialBlock| { &m.materials },
            |m: &mut MaterialBlock| { &mut m.materials },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MaterialBlock>(
            "MaterialBlock",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MaterialBlock {
    const NAME: &'static str = "MaterialBlock";

    fn is_initialized(&self) -> bool {
        for v in &self.materials {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.materials.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.materials {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.materials {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MaterialBlock {
        MaterialBlock::new()
    }

    fn clear(&mut self) {
        self.materials.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MaterialBlock {
        static instance: MaterialBlock = MaterialBlock {
            materials: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MaterialBlock {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MaterialBlock").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MaterialBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MaterialBlock {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  a set of material properties, using RGB colors.
///  Color components are in the range [0, 255]. 
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:frontend_pbf.Material)
pub struct Material {
    // message fields
    // @@protoc_insertion_point(field:frontend_pbf.Material.baseColorR)
    pub baseColorR: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:frontend_pbf.Material.baseColorG)
    pub baseColorG: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:frontend_pbf.Material.baseColorB)
    pub baseColorB: ::std::option::Option<u32>,
    ///  texture layers, ordered from bottom to top 
    // @@protoc_insertion_point(field:frontend_pbf.Material.textureLayer)
    pub textureLayer: ::std::vec::Vec<material::TextureLayer>,
    ///  the type of transparency 
    // @@protoc_insertion_point(field:frontend_pbf.Material.transparency)
    pub transparency: ::std::option::Option<::protobuf::EnumOrUnknown<material::Transparency>>,
    ///  whether this material casts shadows 
    // @@protoc_insertion_point(field:frontend_pbf.Material.castShadow)
    pub castShadow: ::std::option::Option<bool>,
    ///  whether this material is double-sided.
    ///  If true, backface culling should be disabled,
    ///  and two-sided lighting should be enabled. 
    // @@protoc_insertion_point(field:frontend_pbf.Material.doubleSided)
    pub doubleSided: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:frontend_pbf.Material.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Material {
    fn default() -> &'a Material {
        <Material as ::protobuf::Message>::default_instance()
    }
}

impl Material {
    pub fn new() -> Material {
        ::std::default::Default::default()
    }

    // required uint32 baseColorR = 1;

    pub fn baseColorR(&self) -> u32 {
        self.baseColorR.unwrap_or(0)
    }

    pub fn clear_baseColorR(&mut self) {
        self.baseColorR = ::std::option::Option::None;
    }

    pub fn has_baseColorR(&self) -> bool {
        self.baseColorR.is_some()
    }

    // Param is passed by value, moved
    pub fn set_baseColorR(&mut self, v: u32) {
        self.baseColorR = ::std::option::Option::Some(v);
    }

    // required uint32 baseColorG = 2;

    pub fn baseColorG(&self) -> u32 {
        self.baseColorG.unwrap_or(0)
    }

    pub fn clear_baseColorG(&mut self) {
        self.baseColorG = ::std::option::Option::None;
    }

    pub fn has_baseColorG(&self) -> bool {
        self.baseColorG.is_some()
    }

    // Param is passed by value, moved
    pub fn set_baseColorG(&mut self, v: u32) {
        self.baseColorG = ::std::option::Option::Some(v);
    }

    // required uint32 baseColorB = 3;

    pub fn baseColorB(&self) -> u32 {
        self.baseColorB.unwrap_or(0)
    }

    pub fn clear_baseColorB(&mut self) {
        self.baseColorB = ::std::option::Option::None;
    }

    pub fn has_baseColorB(&self) -> bool {
        self.baseColorB.is_some()
    }

    // Param is passed by value, moved
    pub fn set_baseColorB(&mut self, v: u32) {
        self.baseColorB = ::std::option::Option::Some(v);
    }

    // optional .frontend_pbf.Material.Transparency transparency = 16;

    pub fn transparency(&self) -> material::Transparency {
        match self.transparency {
            Some(e) => e.enum_value_or(material::Transparency::FALSE),
            None => material::Transparency::FALSE,
        }
    }

    pub fn clear_transparency(&mut self) {
        self.transparency = ::std::option::Option::None;
    }

    pub fn has_transparency(&self) -> bool {
        self.transparency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transparency(&mut self, v: material::Transparency) {
        self.transparency = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool castShadow = 17;

    pub fn castShadow(&self) -> bool {
        self.castShadow.unwrap_or(true)
    }

    pub fn clear_castShadow(&mut self) {
        self.castShadow = ::std::option::Option::None;
    }

    pub fn has_castShadow(&self) -> bool {
        self.castShadow.is_some()
    }

    // Param is passed by value, moved
    pub fn set_castShadow(&mut self, v: bool) {
        self.castShadow = ::std::option::Option::Some(v);
    }

    // optional bool doubleSided = 18;

    pub fn doubleSided(&self) -> bool {
        self.doubleSided.unwrap_or(false)
    }

    pub fn clear_doubleSided(&mut self) {
        self.doubleSided = ::std::option::Option::None;
    }

    pub fn has_doubleSided(&self) -> bool {
        self.doubleSided.is_some()
    }

    // Param is passed by value, moved
    pub fn set_doubleSided(&mut self, v: bool) {
        self.doubleSided = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "baseColorR",
            |m: &Material| { &m.baseColorR },
            |m: &mut Material| { &mut m.baseColorR },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "baseColorG",
            |m: &Material| { &m.baseColorG },
            |m: &mut Material| { &mut m.baseColorG },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "baseColorB",
            |m: &Material| { &m.baseColorB },
            |m: &mut Material| { &mut m.baseColorB },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "textureLayer",
            |m: &Material| { &m.textureLayer },
            |m: &mut Material| { &mut m.textureLayer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "transparency",
            |m: &Material| { &m.transparency },
            |m: &mut Material| { &mut m.transparency },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "castShadow",
            |m: &Material| { &m.castShadow },
            |m: &mut Material| { &mut m.castShadow },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "doubleSided",
            |m: &Material| { &m.doubleSided },
            |m: &mut Material| { &mut m.doubleSided },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Material>(
            "Material",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Material {
    const NAME: &'static str = "Material";

    fn is_initialized(&self) -> bool {
        if self.baseColorR.is_none() {
            return false;
        }
        if self.baseColorG.is_none() {
            return false;
        }
        if self.baseColorB.is_none() {
            return false;
        }
        for v in &self.textureLayer {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.baseColorR = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.baseColorG = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.baseColorB = ::std::option::Option::Some(is.read_uint32()?);
                },
                90 => {
                    self.textureLayer.push(is.read_message()?);
                },
                128 => {
                    self.transparency = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                136 => {
                    self.castShadow = ::std::option::Option::Some(is.read_bool()?);
                },
                144 => {
                    self.doubleSided = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.baseColorR {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.baseColorG {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.baseColorB {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        for value in &self.textureLayer {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.transparency {
            my_size += ::protobuf::rt::int32_size(16, v.value());
        }
        if let Some(v) = self.castShadow {
            my_size += 2 + 1;
        }
        if let Some(v) = self.doubleSided {
            my_size += 2 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.baseColorR {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.baseColorG {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.baseColorB {
            os.write_uint32(3, v)?;
        }
        for v in &self.textureLayer {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        if let Some(v) = self.transparency {
            os.write_enum(16, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.castShadow {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.doubleSided {
            os.write_bool(18, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Material {
        Material::new()
    }

    fn clear(&mut self) {
        self.baseColorR = ::std::option::Option::None;
        self.baseColorG = ::std::option::Option::None;
        self.baseColorB = ::std::option::Option::None;
        self.textureLayer.clear();
        self.transparency = ::std::option::Option::None;
        self.castShadow = ::std::option::Option::None;
        self.doubleSided = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Material {
        static instance: Material = Material {
            baseColorR: ::std::option::Option::None,
            baseColorG: ::std::option::Option::None,
            baseColorB: ::std::option::Option::None,
            textureLayer: ::std::vec::Vec::new(),
            transparency: ::std::option::Option::None,
            castShadow: ::std::option::Option::None,
            doubleSided: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Material {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Material").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Material {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Material {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Material`
pub mod material {
    /// * a set of PBR textures representing one layer of the material. All textures in the layer use the same texture coordinates. 
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:frontend_pbf.Material.TextureLayer)
    pub struct TextureLayer {
        // message fields
        ///  URI of the base color + alpha texture image, can be relative, can be a data URI 
        // @@protoc_insertion_point(field:frontend_pbf.Material.TextureLayer.baseColorTextureURI)
        pub baseColorTextureURI: ::std::option::Option<::std::string::String>,
        ///  URI of the occlusion/roughness/metalness texture image, can be relative, can be a data URI 
        // @@protoc_insertion_point(field:frontend_pbf.Material.TextureLayer.ormTextureURI)
        pub ormTextureURI: ::std::option::Option<::std::string::String>,
        ///  URI of the normal map texture image, can be relative, can be a data URI 
        // @@protoc_insertion_point(field:frontend_pbf.Material.TextureLayer.normalTextureURI)
        pub normalTextureURI: ::std::option::Option<::std::string::String>,
        ///  URI of the displacement map texture image, can be relative, can be a data URI 
        // @@protoc_insertion_point(field:frontend_pbf.Material.TextureLayer.displacementTextureURI)
        pub displacementTextureURI: ::std::option::Option<::std::string::String>,
        ///  URI of the emissive texture image, can be relative, can be a data URI 
        // @@protoc_insertion_point(field:frontend_pbf.Material.TextureLayer.emissiveTextureURI)
        pub emissiveTextureURI: ::std::option::Option<::std::string::String>,
        ///  URI of the reflectivity texture image, can be relative, can be a data URI 
        // @@protoc_insertion_point(field:frontend_pbf.Material.TextureLayer.reflectivityTextureURI)
        pub reflectivityTextureURI: ::std::option::Option<::std::string::String>,
        ///  how the texture behaves for texture coordinates
        ///  less than 0 or greater than 1 
        // @@protoc_insertion_point(field:frontend_pbf.Material.TextureLayer.wrap)
        pub wrap: ::std::option::Option<::protobuf::EnumOrUnknown<texture_layer::Wrap>>,
        ///  whether the base color texture should be multiplied with the material's base color value 
        // @@protoc_insertion_point(field:frontend_pbf.Material.TextureLayer.colorable)
        pub colorable: ::std::option::Option<bool>,
        ///  width of the texture in millimeters. 
        // @@protoc_insertion_point(field:frontend_pbf.Material.TextureLayer.textureWidth)
        pub textureWidth: ::std::option::Option<u32>,
        ///  height of the texture in millimeters. 
        // @@protoc_insertion_point(field:frontend_pbf.Material.TextureLayer.textureHeight)
        pub textureHeight: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:frontend_pbf.Material.TextureLayer.texCoordFunction)
        pub texCoordFunction: ::std::option::Option<::protobuf::EnumOrUnknown<texture_layer::TexCoordFunction>>,
        // special fields
        // @@protoc_insertion_point(special_field:frontend_pbf.Material.TextureLayer.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TextureLayer {
        fn default() -> &'a TextureLayer {
            <TextureLayer as ::protobuf::Message>::default_instance()
        }
    }

    impl TextureLayer {
        pub fn new() -> TextureLayer {
            ::std::default::Default::default()
        }

        // optional string baseColorTextureURI = 1;

        pub fn baseColorTextureURI(&self) -> &str {
            match self.baseColorTextureURI.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_baseColorTextureURI(&mut self) {
            self.baseColorTextureURI = ::std::option::Option::None;
        }

        pub fn has_baseColorTextureURI(&self) -> bool {
            self.baseColorTextureURI.is_some()
        }

        // Param is passed by value, moved
        pub fn set_baseColorTextureURI(&mut self, v: ::std::string::String) {
            self.baseColorTextureURI = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_baseColorTextureURI(&mut self) -> &mut ::std::string::String {
            if self.baseColorTextureURI.is_none() {
                self.baseColorTextureURI = ::std::option::Option::Some(::std::string::String::new());
            }
            self.baseColorTextureURI.as_mut().unwrap()
        }

        // Take field
        pub fn take_baseColorTextureURI(&mut self) -> ::std::string::String {
            self.baseColorTextureURI.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string ormTextureURI = 7;

        pub fn ormTextureURI(&self) -> &str {
            match self.ormTextureURI.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_ormTextureURI(&mut self) {
            self.ormTextureURI = ::std::option::Option::None;
        }

        pub fn has_ormTextureURI(&self) -> bool {
            self.ormTextureURI.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ormTextureURI(&mut self, v: ::std::string::String) {
            self.ormTextureURI = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_ormTextureURI(&mut self) -> &mut ::std::string::String {
            if self.ormTextureURI.is_none() {
                self.ormTextureURI = ::std::option::Option::Some(::std::string::String::new());
            }
            self.ormTextureURI.as_mut().unwrap()
        }

        // Take field
        pub fn take_ormTextureURI(&mut self) -> ::std::string::String {
            self.ormTextureURI.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string normalTextureURI = 8;

        pub fn normalTextureURI(&self) -> &str {
            match self.normalTextureURI.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_normalTextureURI(&mut self) {
            self.normalTextureURI = ::std::option::Option::None;
        }

        pub fn has_normalTextureURI(&self) -> bool {
            self.normalTextureURI.is_some()
        }

        // Param is passed by value, moved
        pub fn set_normalTextureURI(&mut self, v: ::std::string::String) {
            self.normalTextureURI = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_normalTextureURI(&mut self) -> &mut ::std::string::String {
            if self.normalTextureURI.is_none() {
                self.normalTextureURI = ::std::option::Option::Some(::std::string::String::new());
            }
            self.normalTextureURI.as_mut().unwrap()
        }

        // Take field
        pub fn take_normalTextureURI(&mut self) -> ::std::string::String {
            self.normalTextureURI.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string displacementTextureURI = 9;

        pub fn displacementTextureURI(&self) -> &str {
            match self.displacementTextureURI.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_displacementTextureURI(&mut self) {
            self.displacementTextureURI = ::std::option::Option::None;
        }

        pub fn has_displacementTextureURI(&self) -> bool {
            self.displacementTextureURI.is_some()
        }

        // Param is passed by value, moved
        pub fn set_displacementTextureURI(&mut self, v: ::std::string::String) {
            self.displacementTextureURI = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_displacementTextureURI(&mut self) -> &mut ::std::string::String {
            if self.displacementTextureURI.is_none() {
                self.displacementTextureURI = ::std::option::Option::Some(::std::string::String::new());
            }
            self.displacementTextureURI.as_mut().unwrap()
        }

        // Take field
        pub fn take_displacementTextureURI(&mut self) -> ::std::string::String {
            self.displacementTextureURI.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string emissiveTextureURI = 10;

        pub fn emissiveTextureURI(&self) -> &str {
            match self.emissiveTextureURI.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_emissiveTextureURI(&mut self) {
            self.emissiveTextureURI = ::std::option::Option::None;
        }

        pub fn has_emissiveTextureURI(&self) -> bool {
            self.emissiveTextureURI.is_some()
        }

        // Param is passed by value, moved
        pub fn set_emissiveTextureURI(&mut self, v: ::std::string::String) {
            self.emissiveTextureURI = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_emissiveTextureURI(&mut self) -> &mut ::std::string::String {
            if self.emissiveTextureURI.is_none() {
                self.emissiveTextureURI = ::std::option::Option::Some(::std::string::String::new());
            }
            self.emissiveTextureURI.as_mut().unwrap()
        }

        // Take field
        pub fn take_emissiveTextureURI(&mut self) -> ::std::string::String {
            self.emissiveTextureURI.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string reflectivityTextureURI = 11;

        pub fn reflectivityTextureURI(&self) -> &str {
            match self.reflectivityTextureURI.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_reflectivityTextureURI(&mut self) {
            self.reflectivityTextureURI = ::std::option::Option::None;
        }

        pub fn has_reflectivityTextureURI(&self) -> bool {
            self.reflectivityTextureURI.is_some()
        }

        // Param is passed by value, moved
        pub fn set_reflectivityTextureURI(&mut self, v: ::std::string::String) {
            self.reflectivityTextureURI = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_reflectivityTextureURI(&mut self) -> &mut ::std::string::String {
            if self.reflectivityTextureURI.is_none() {
                self.reflectivityTextureURI = ::std::option::Option::Some(::std::string::String::new());
            }
            self.reflectivityTextureURI.as_mut().unwrap()
        }

        // Take field
        pub fn take_reflectivityTextureURI(&mut self) -> ::std::string::String {
            self.reflectivityTextureURI.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional .frontend_pbf.Material.TextureLayer.Wrap wrap = 2;

        pub fn wrap(&self) -> texture_layer::Wrap {
            match self.wrap {
                Some(e) => e.enum_value_or(texture_layer::Wrap::REPEAT),
                None => texture_layer::Wrap::REPEAT,
            }
        }

        pub fn clear_wrap(&mut self) {
            self.wrap = ::std::option::Option::None;
        }

        pub fn has_wrap(&self) -> bool {
            self.wrap.is_some()
        }

        // Param is passed by value, moved
        pub fn set_wrap(&mut self, v: texture_layer::Wrap) {
            self.wrap = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // required bool colorable = 3;

        pub fn colorable(&self) -> bool {
            self.colorable.unwrap_or(false)
        }

        pub fn clear_colorable(&mut self) {
            self.colorable = ::std::option::Option::None;
        }

        pub fn has_colorable(&self) -> bool {
            self.colorable.is_some()
        }

        // Param is passed by value, moved
        pub fn set_colorable(&mut self, v: bool) {
            self.colorable = ::std::option::Option::Some(v);
        }

        // required uint32 textureWidth = 4;

        pub fn textureWidth(&self) -> u32 {
            self.textureWidth.unwrap_or(0)
        }

        pub fn clear_textureWidth(&mut self) {
            self.textureWidth = ::std::option::Option::None;
        }

        pub fn has_textureWidth(&self) -> bool {
            self.textureWidth.is_some()
        }

        // Param is passed by value, moved
        pub fn set_textureWidth(&mut self, v: u32) {
            self.textureWidth = ::std::option::Option::Some(v);
        }

        // required uint32 textureHeight = 5;

        pub fn textureHeight(&self) -> u32 {
            self.textureHeight.unwrap_or(0)
        }

        pub fn clear_textureHeight(&mut self) {
            self.textureHeight = ::std::option::Option::None;
        }

        pub fn has_textureHeight(&self) -> bool {
            self.textureHeight.is_some()
        }

        // Param is passed by value, moved
        pub fn set_textureHeight(&mut self, v: u32) {
            self.textureHeight = ::std::option::Option::Some(v);
        }

        // optional .frontend_pbf.Material.TextureLayer.TexCoordFunction texCoordFunction = 6;

        pub fn texCoordFunction(&self) -> texture_layer::TexCoordFunction {
            match self.texCoordFunction {
                Some(e) => e.enum_value_or(texture_layer::TexCoordFunction::CUSTOM),
                None => texture_layer::TexCoordFunction::CUSTOM,
            }
        }

        pub fn clear_texCoordFunction(&mut self) {
            self.texCoordFunction = ::std::option::Option::None;
        }

        pub fn has_texCoordFunction(&self) -> bool {
            self.texCoordFunction.is_some()
        }

        // Param is passed by value, moved
        pub fn set_texCoordFunction(&mut self, v: texture_layer::TexCoordFunction) {
            self.texCoordFunction = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(11);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "baseColorTextureURI",
                |m: &TextureLayer| { &m.baseColorTextureURI },
                |m: &mut TextureLayer| { &mut m.baseColorTextureURI },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "ormTextureURI",
                |m: &TextureLayer| { &m.ormTextureURI },
                |m: &mut TextureLayer| { &mut m.ormTextureURI },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "normalTextureURI",
                |m: &TextureLayer| { &m.normalTextureURI },
                |m: &mut TextureLayer| { &mut m.normalTextureURI },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "displacementTextureURI",
                |m: &TextureLayer| { &m.displacementTextureURI },
                |m: &mut TextureLayer| { &mut m.displacementTextureURI },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "emissiveTextureURI",
                |m: &TextureLayer| { &m.emissiveTextureURI },
                |m: &mut TextureLayer| { &mut m.emissiveTextureURI },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "reflectivityTextureURI",
                |m: &TextureLayer| { &m.reflectivityTextureURI },
                |m: &mut TextureLayer| { &mut m.reflectivityTextureURI },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "wrap",
                |m: &TextureLayer| { &m.wrap },
                |m: &mut TextureLayer| { &mut m.wrap },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "colorable",
                |m: &TextureLayer| { &m.colorable },
                |m: &mut TextureLayer| { &mut m.colorable },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "textureWidth",
                |m: &TextureLayer| { &m.textureWidth },
                |m: &mut TextureLayer| { &mut m.textureWidth },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "textureHeight",
                |m: &TextureLayer| { &m.textureHeight },
                |m: &mut TextureLayer| { &mut m.textureHeight },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "texCoordFunction",
                |m: &TextureLayer| { &m.texCoordFunction },
                |m: &mut TextureLayer| { &mut m.texCoordFunction },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TextureLayer>(
                "Material.TextureLayer",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for TextureLayer {
        const NAME: &'static str = "TextureLayer";

        fn is_initialized(&self) -> bool {
            if self.colorable.is_none() {
                return false;
            }
            if self.textureWidth.is_none() {
                return false;
            }
            if self.textureHeight.is_none() {
                return false;
            }
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.baseColorTextureURI = ::std::option::Option::Some(is.read_string()?);
                    },
                    58 => {
                        self.ormTextureURI = ::std::option::Option::Some(is.read_string()?);
                    },
                    66 => {
                        self.normalTextureURI = ::std::option::Option::Some(is.read_string()?);
                    },
                    74 => {
                        self.displacementTextureURI = ::std::option::Option::Some(is.read_string()?);
                    },
                    82 => {
                        self.emissiveTextureURI = ::std::option::Option::Some(is.read_string()?);
                    },
                    90 => {
                        self.reflectivityTextureURI = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.wrap = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    24 => {
                        self.colorable = ::std::option::Option::Some(is.read_bool()?);
                    },
                    32 => {
                        self.textureWidth = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.textureHeight = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.texCoordFunction = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.baseColorTextureURI.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.ormTextureURI.as_ref() {
                my_size += ::protobuf::rt::string_size(7, &v);
            }
            if let Some(v) = self.normalTextureURI.as_ref() {
                my_size += ::protobuf::rt::string_size(8, &v);
            }
            if let Some(v) = self.displacementTextureURI.as_ref() {
                my_size += ::protobuf::rt::string_size(9, &v);
            }
            if let Some(v) = self.emissiveTextureURI.as_ref() {
                my_size += ::protobuf::rt::string_size(10, &v);
            }
            if let Some(v) = self.reflectivityTextureURI.as_ref() {
                my_size += ::protobuf::rt::string_size(11, &v);
            }
            if let Some(v) = self.wrap {
                my_size += ::protobuf::rt::int32_size(2, v.value());
            }
            if let Some(v) = self.colorable {
                my_size += 1 + 1;
            }
            if let Some(v) = self.textureWidth {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.textureHeight {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.texCoordFunction {
                my_size += ::protobuf::rt::int32_size(6, v.value());
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.baseColorTextureURI.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.ormTextureURI.as_ref() {
                os.write_string(7, v)?;
            }
            if let Some(v) = self.normalTextureURI.as_ref() {
                os.write_string(8, v)?;
            }
            if let Some(v) = self.displacementTextureURI.as_ref() {
                os.write_string(9, v)?;
            }
            if let Some(v) = self.emissiveTextureURI.as_ref() {
                os.write_string(10, v)?;
            }
            if let Some(v) = self.reflectivityTextureURI.as_ref() {
                os.write_string(11, v)?;
            }
            if let Some(v) = self.wrap {
                os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.colorable {
                os.write_bool(3, v)?;
            }
            if let Some(v) = self.textureWidth {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.textureHeight {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.texCoordFunction {
                os.write_enum(6, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TextureLayer {
            TextureLayer::new()
        }

        fn clear(&mut self) {
            self.baseColorTextureURI = ::std::option::Option::None;
            self.ormTextureURI = ::std::option::Option::None;
            self.normalTextureURI = ::std::option::Option::None;
            self.displacementTextureURI = ::std::option::Option::None;
            self.emissiveTextureURI = ::std::option::Option::None;
            self.reflectivityTextureURI = ::std::option::Option::None;
            self.wrap = ::std::option::Option::None;
            self.colorable = ::std::option::Option::None;
            self.textureWidth = ::std::option::Option::None;
            self.textureHeight = ::std::option::Option::None;
            self.texCoordFunction = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TextureLayer {
            static instance: TextureLayer = TextureLayer {
                baseColorTextureURI: ::std::option::Option::None,
                ormTextureURI: ::std::option::Option::None,
                normalTextureURI: ::std::option::Option::None,
                displacementTextureURI: ::std::option::Option::None,
                emissiveTextureURI: ::std::option::Option::None,
                reflectivityTextureURI: ::std::option::Option::None,
                wrap: ::std::option::Option::None,
                colorable: ::std::option::Option::None,
                textureWidth: ::std::option::Option::None,
                textureHeight: ::std::option::Option::None,
                texCoordFunction: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for TextureLayer {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Material.TextureLayer").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for TextureLayer {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for TextureLayer {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `TextureLayer`
    pub mod texture_layer {
        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:frontend_pbf.Material.TextureLayer.Wrap)
        pub enum Wrap {
            // @@protoc_insertion_point(enum_value:frontend_pbf.Material.TextureLayer.Wrap.REPEAT)
            REPEAT = 1,
            // @@protoc_insertion_point(enum_value:frontend_pbf.Material.TextureLayer.Wrap.CLAMP)
            CLAMP = 2,
        }

        impl ::protobuf::Enum for Wrap {
            const NAME: &'static str = "Wrap";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<Wrap> {
                match value {
                    1 => ::std::option::Option::Some(Wrap::REPEAT),
                    2 => ::std::option::Option::Some(Wrap::CLAMP),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [Wrap] = &[
                Wrap::REPEAT,
                Wrap::CLAMP,
            ];
        }

        impl ::protobuf::EnumFull for Wrap {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("Material.TextureLayer.Wrap").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = match self {
                    Wrap::REPEAT => 0,
                    Wrap::CLAMP => 1,
                };
                Self::enum_descriptor().value_by_index(index)
            }
        }

        // Note, `Default` is implemented although default value is not 0
        impl ::std::default::Default for Wrap {
            fn default() -> Self {
                Wrap::REPEAT
            }
        }

        impl Wrap {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Wrap>("Material.TextureLayer.Wrap")
            }
        }

        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:frontend_pbf.Material.TextureLayer.TexCoordFunction)
        pub enum TexCoordFunction {
            // @@protoc_insertion_point(enum_value:frontend_pbf.Material.TextureLayer.TexCoordFunction.CUSTOM)
            CUSTOM = 1,
            // @@protoc_insertion_point(enum_value:frontend_pbf.Material.TextureLayer.TexCoordFunction.GLOBAL_X_Z)
            GLOBAL_X_Z = 2,
        }

        impl ::protobuf::Enum for TexCoordFunction {
            const NAME: &'static str = "TexCoordFunction";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<TexCoordFunction> {
                match value {
                    1 => ::std::option::Option::Some(TexCoordFunction::CUSTOM),
                    2 => ::std::option::Option::Some(TexCoordFunction::GLOBAL_X_Z),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [TexCoordFunction] = &[
                TexCoordFunction::CUSTOM,
                TexCoordFunction::GLOBAL_X_Z,
            ];
        }

        impl ::protobuf::EnumFull for TexCoordFunction {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("Material.TextureLayer.TexCoordFunction").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = match self {
                    TexCoordFunction::CUSTOM => 0,
                    TexCoordFunction::GLOBAL_X_Z => 1,
                };
                Self::enum_descriptor().value_by_index(index)
            }
        }

        // Note, `Default` is implemented although default value is not 0
        impl ::std::default::Default for TexCoordFunction {
            fn default() -> Self {
                TexCoordFunction::CUSTOM
            }
        }

        impl TexCoordFunction {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<TexCoordFunction>("Material.TextureLayer.TexCoordFunction")
            }
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:frontend_pbf.Material.Transparency)
    pub enum Transparency {
        // @@protoc_insertion_point(enum_value:frontend_pbf.Material.Transparency.TRUE)
        TRUE = 1,
        // @@protoc_insertion_point(enum_value:frontend_pbf.Material.Transparency.BINARY)
        BINARY = 2,
        // @@protoc_insertion_point(enum_value:frontend_pbf.Material.Transparency.FALSE)
        FALSE = 3,
    }

    impl ::protobuf::Enum for Transparency {
        const NAME: &'static str = "Transparency";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Transparency> {
            match value {
                1 => ::std::option::Option::Some(Transparency::TRUE),
                2 => ::std::option::Option::Some(Transparency::BINARY),
                3 => ::std::option::Option::Some(Transparency::FALSE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Transparency] = &[
            Transparency::TRUE,
            Transparency::BINARY,
            Transparency::FALSE,
        ];
    }

    impl ::protobuf::EnumFull for Transparency {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Material.Transparency").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Transparency::TRUE => 0,
                Transparency::BINARY => 1,
                Transparency::FALSE => 2,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Transparency {
        fn default() -> Self {
            Transparency::TRUE
        }
    }

    impl Transparency {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Transparency>("Material.Transparency")
        }
    }
}

///  a block containing all template models used in this file.
///  Each model is represented as a WorldObject with no id or type.
///  A template model must not use InstanceGeometry itself. 
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:frontend_pbf.ModelBlock)
pub struct ModelBlock {
    // message fields
    ///  the template models that can be copied (with slight variations) in multiple locations 
    // @@protoc_insertion_point(field:frontend_pbf.ModelBlock.models)
    pub models: ::std::vec::Vec<WorldObject>,
    // special fields
    // @@protoc_insertion_point(special_field:frontend_pbf.ModelBlock.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ModelBlock {
    fn default() -> &'a ModelBlock {
        <ModelBlock as ::protobuf::Message>::default_instance()
    }
}

impl ModelBlock {
    pub fn new() -> ModelBlock {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "models",
            |m: &ModelBlock| { &m.models },
            |m: &mut ModelBlock| { &mut m.models },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ModelBlock>(
            "ModelBlock",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ModelBlock {
    const NAME: &'static str = "ModelBlock";

    fn is_initialized(&self) -> bool {
        for v in &self.models {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.models.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.models {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.models {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ModelBlock {
        ModelBlock::new()
    }

    fn clear(&mut self) {
        self.models.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ModelBlock {
        static instance: ModelBlock = ModelBlock {
            models: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ModelBlock {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ModelBlock").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ModelBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModelBlock {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  geometry consisting of a set of triangles 
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:frontend_pbf.TriangleGeometry)
pub struct TriangleGeometry {
    // message fields
    ///  the geometry's material, referencing materialBlock 
    // @@protoc_insertion_point(field:frontend_pbf.TriangleGeometry.material)
    pub material: ::std::option::Option<u32>,
    ///  vertices of the triangles, represented as
    ///  3 references to the Vector3d block each.
    ///  At least 1 triangle (i.e. 3 vertex references) required. 
    // @@protoc_insertion_point(field:frontend_pbf.TriangleGeometry.vertices)
    pub vertices: ::std::vec::Vec<u64>,
    ///  texture coordinates for each vertex of the triangles,
    ///  referencing the Vector2d block.
    ///  Texture coordinates are only provided for those layers
    ///  which are using the CUSTOM texture coordinate function (see Material).
    ///  The length of this list is that of
    ///  vertices, times the number of CUSTOM-coordinated texture layers.
    ///  Starts with all vertices' tex coords for layer 0, then 1 etc. 
    // @@protoc_insertion_point(field:frontend_pbf.TriangleGeometry.texCoords)
    pub texCoords: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:frontend_pbf.TriangleGeometry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TriangleGeometry {
    fn default() -> &'a TriangleGeometry {
        <TriangleGeometry as ::protobuf::Message>::default_instance()
    }
}

impl TriangleGeometry {
    pub fn new() -> TriangleGeometry {
        ::std::default::Default::default()
    }

    // required uint32 material = 1;

    pub fn material(&self) -> u32 {
        self.material.unwrap_or(0)
    }

    pub fn clear_material(&mut self) {
        self.material = ::std::option::Option::None;
    }

    pub fn has_material(&self) -> bool {
        self.material.is_some()
    }

    // Param is passed by value, moved
    pub fn set_material(&mut self, v: u32) {
        self.material = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "material",
            |m: &TriangleGeometry| { &m.material },
            |m: &mut TriangleGeometry| { &mut m.material },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "vertices",
            |m: &TriangleGeometry| { &m.vertices },
            |m: &mut TriangleGeometry| { &mut m.vertices },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "texCoords",
            |m: &TriangleGeometry| { &m.texCoords },
            |m: &mut TriangleGeometry| { &mut m.texCoords },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TriangleGeometry>(
            "TriangleGeometry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TriangleGeometry {
    const NAME: &'static str = "TriangleGeometry";

    fn is_initialized(&self) -> bool {
        if self.material.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.material = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint64_into(&mut self.vertices)?;
                },
                16 => {
                    self.vertices.push(is.read_uint64()?);
                },
                26 => {
                    is.read_repeated_packed_uint64_into(&mut self.texCoords)?;
                },
                24 => {
                    self.texCoords.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.material {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::vec_packed_uint64_size(2, &self.vertices);
        my_size += ::protobuf::rt::vec_packed_uint64_size(3, &self.texCoords);
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.material {
            os.write_uint32(1, v)?;
        }
        os.write_repeated_packed_uint64(2, &self.vertices)?;
        os.write_repeated_packed_uint64(3, &self.texCoords)?;
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TriangleGeometry {
        TriangleGeometry::new()
    }

    fn clear(&mut self) {
        self.material = ::std::option::Option::None;
        self.vertices.clear();
        self.texCoords.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TriangleGeometry {
        static instance: TriangleGeometry = TriangleGeometry {
            material: ::std::option::Option::None,
            vertices: ::std::vec::Vec::new(),
            texCoords: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TriangleGeometry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TriangleGeometry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TriangleGeometry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TriangleGeometry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  geometry produced by extruding a 2d shape.
/// See OSM2World's Target.drawExtrudedShape method for documentation of the parameters. 
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:frontend_pbf.ExtrusionGeometry)
pub struct ExtrusionGeometry {
    // message fields
    ///  the geometry's material, referencing materialBlock 
    // @@protoc_insertion_point(field:frontend_pbf.ExtrusionGeometry.material)
    pub material: ::std::option::Option<u32>,
    ///  the shape to be extruded, referencing shapeBlock 
    // @@protoc_insertion_point(field:frontend_pbf.ExtrusionGeometry.shape)
    pub shape: ::std::option::Option<u32>,
    ///  referencing vector3dBlock 
    // @@protoc_insertion_point(field:frontend_pbf.ExtrusionGeometry.path)
    pub path: ::std::vec::Vec<u64>,
    ///  referencing vector3dBlock. Same length as path. Can be omitted, defaults to z unit vector. 
    // @@protoc_insertion_point(field:frontend_pbf.ExtrusionGeometry.upVectors)
    pub upVectors: ::std::vec::Vec<u64>,
    ///  multiplicative factor, times 1000. Either omitted (if no scaling is applied) or same length as path. 
    // @@protoc_insertion_point(field:frontend_pbf.ExtrusionGeometry.scaleFactors)
    pub scaleFactors: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:frontend_pbf.ExtrusionGeometry.startCap)
    pub startCap: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:frontend_pbf.ExtrusionGeometry.endCap)
    pub endCap: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:frontend_pbf.ExtrusionGeometry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ExtrusionGeometry {
    fn default() -> &'a ExtrusionGeometry {
        <ExtrusionGeometry as ::protobuf::Message>::default_instance()
    }
}

impl ExtrusionGeometry {
    pub fn new() -> ExtrusionGeometry {
        ::std::default::Default::default()
    }

    // required uint32 material = 1;

    pub fn material(&self) -> u32 {
        self.material.unwrap_or(0)
    }

    pub fn clear_material(&mut self) {
        self.material = ::std::option::Option::None;
    }

    pub fn has_material(&self) -> bool {
        self.material.is_some()
    }

    // Param is passed by value, moved
    pub fn set_material(&mut self, v: u32) {
        self.material = ::std::option::Option::Some(v);
    }

    // required uint32 shape = 2;

    pub fn shape(&self) -> u32 {
        self.shape.unwrap_or(0)
    }

    pub fn clear_shape(&mut self) {
        self.shape = ::std::option::Option::None;
    }

    pub fn has_shape(&self) -> bool {
        self.shape.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shape(&mut self, v: u32) {
        self.shape = ::std::option::Option::Some(v);
    }

    // optional bool startCap = 7;

    pub fn startCap(&self) -> bool {
        self.startCap.unwrap_or(false)
    }

    pub fn clear_startCap(&mut self) {
        self.startCap = ::std::option::Option::None;
    }

    pub fn has_startCap(&self) -> bool {
        self.startCap.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startCap(&mut self, v: bool) {
        self.startCap = ::std::option::Option::Some(v);
    }

    // optional bool endCap = 8;

    pub fn endCap(&self) -> bool {
        self.endCap.unwrap_or(false)
    }

    pub fn clear_endCap(&mut self) {
        self.endCap = ::std::option::Option::None;
    }

    pub fn has_endCap(&self) -> bool {
        self.endCap.is_some()
    }

    // Param is passed by value, moved
    pub fn set_endCap(&mut self, v: bool) {
        self.endCap = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "material",
            |m: &ExtrusionGeometry| { &m.material },
            |m: &mut ExtrusionGeometry| { &mut m.material },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "shape",
            |m: &ExtrusionGeometry| { &m.shape },
            |m: &mut ExtrusionGeometry| { &mut m.shape },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "path",
            |m: &ExtrusionGeometry| { &m.path },
            |m: &mut ExtrusionGeometry| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "upVectors",
            |m: &ExtrusionGeometry| { &m.upVectors },
            |m: &mut ExtrusionGeometry| { &mut m.upVectors },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "scaleFactors",
            |m: &ExtrusionGeometry| { &m.scaleFactors },
            |m: &mut ExtrusionGeometry| { &mut m.scaleFactors },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "startCap",
            |m: &ExtrusionGeometry| { &m.startCap },
            |m: &mut ExtrusionGeometry| { &mut m.startCap },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "endCap",
            |m: &ExtrusionGeometry| { &m.endCap },
            |m: &mut ExtrusionGeometry| { &mut m.endCap },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExtrusionGeometry>(
            "ExtrusionGeometry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ExtrusionGeometry {
    const NAME: &'static str = "ExtrusionGeometry";

    fn is_initialized(&self) -> bool {
        if self.material.is_none() {
            return false;
        }
        if self.shape.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.material = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.shape = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    is.read_repeated_packed_uint64_into(&mut self.path)?;
                },
                24 => {
                    self.path.push(is.read_uint64()?);
                },
                34 => {
                    is.read_repeated_packed_uint64_into(&mut self.upVectors)?;
                },
                32 => {
                    self.upVectors.push(is.read_uint64()?);
                },
                42 => {
                    is.read_repeated_packed_uint64_into(&mut self.scaleFactors)?;
                },
                40 => {
                    self.scaleFactors.push(is.read_uint64()?);
                },
                56 => {
                    self.startCap = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.endCap = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.material {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.shape {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.path {
            my_size += ::protobuf::rt::uint64_size(3, *value);
        };
        for value in &self.upVectors {
            my_size += ::protobuf::rt::uint64_size(4, *value);
        };
        for value in &self.scaleFactors {
            my_size += ::protobuf::rt::uint64_size(5, *value);
        };
        if let Some(v) = self.startCap {
            my_size += 1 + 1;
        }
        if let Some(v) = self.endCap {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.material {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.shape {
            os.write_uint32(2, v)?;
        }
        for v in &self.path {
            os.write_uint64(3, *v)?;
        };
        for v in &self.upVectors {
            os.write_uint64(4, *v)?;
        };
        for v in &self.scaleFactors {
            os.write_uint64(5, *v)?;
        };
        if let Some(v) = self.startCap {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.endCap {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ExtrusionGeometry {
        ExtrusionGeometry::new()
    }

    fn clear(&mut self) {
        self.material = ::std::option::Option::None;
        self.shape = ::std::option::Option::None;
        self.path.clear();
        self.upVectors.clear();
        self.scaleFactors.clear();
        self.startCap = ::std::option::Option::None;
        self.endCap = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ExtrusionGeometry {
        static instance: ExtrusionGeometry = ExtrusionGeometry {
            material: ::std::option::Option::None,
            shape: ::std::option::Option::None,
            path: ::std::vec::Vec::new(),
            upVectors: ::std::vec::Vec::new(),
            scaleFactors: ::std::vec::Vec::new(),
            startCap: ::std::option::Option::None,
            endCap: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ExtrusionGeometry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ExtrusionGeometry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ExtrusionGeometry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExtrusionGeometry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  copies of some prototype model, possibly rotated and scaled 
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:frontend_pbf.InstanceGeometry)
pub struct InstanceGeometry {
    // message fields
    ///  the prototype model, referencing the modelBlock.
    /// Alternatively, an external resource can be referenced using resourceIdentifier. 
    // @@protoc_insertion_point(field:frontend_pbf.InstanceGeometry.model)
    pub model: ::std::option::Option<u32>,
    ///  string identifying an external model in some way, e.g. as an URI or a string constant.
    /// Alternatively, a prototype model included in this file can be referenced using the model field. 
    // @@protoc_insertion_point(field:frontend_pbf.InstanceGeometry.resourceIdentifier)
    pub resourceIdentifier: ::std::option::Option<::std::string::String>,
    ///  position of each instance.
    /// Values are in millimeters relative to the center of the tile (like Vector3dBlock).
    /// Each position is represented as an x, y, z triple of values. 
    // @@protoc_insertion_point(field:frontend_pbf.InstanceGeometry.position)
    pub position: ::std::vec::Vec<i64>,
    ///  rotation angle around the y axis for each instance in milliradians, clockwise.
    /// Either one third of the length of 'position' or empty (for a default of 0). 
    // @@protoc_insertion_point(field:frontend_pbf.InstanceGeometry.direction)
    pub direction: ::std::vec::Vec<i32>,
    ///  scale factor for each instance in 1/1000.
    /// Either one third of the length of 'position' or empty (for a default of 1). 
    // @@protoc_insertion_point(field:frontend_pbf.InstanceGeometry.scale)
    pub scale: ::std::vec::Vec<u32>,
    ///  this message is present if this geometry is animated 
    // @@protoc_insertion_point(field:frontend_pbf.InstanceGeometry.animation)
    pub animation: ::protobuf::MessageField<Animation>,
    // special fields
    // @@protoc_insertion_point(special_field:frontend_pbf.InstanceGeometry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InstanceGeometry {
    fn default() -> &'a InstanceGeometry {
        <InstanceGeometry as ::protobuf::Message>::default_instance()
    }
}

impl InstanceGeometry {
    pub fn new() -> InstanceGeometry {
        ::std::default::Default::default()
    }

    // optional uint32 model = 1;

    pub fn model(&self) -> u32 {
        self.model.unwrap_or(0)
    }

    pub fn clear_model(&mut self) {
        self.model = ::std::option::Option::None;
    }

    pub fn has_model(&self) -> bool {
        self.model.is_some()
    }

    // Param is passed by value, moved
    pub fn set_model(&mut self, v: u32) {
        self.model = ::std::option::Option::Some(v);
    }

    // optional string resourceIdentifier = 5;

    pub fn resourceIdentifier(&self) -> &str {
        match self.resourceIdentifier.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_resourceIdentifier(&mut self) {
        self.resourceIdentifier = ::std::option::Option::None;
    }

    pub fn has_resourceIdentifier(&self) -> bool {
        self.resourceIdentifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceIdentifier(&mut self, v: ::std::string::String) {
        self.resourceIdentifier = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resourceIdentifier(&mut self) -> &mut ::std::string::String {
        if self.resourceIdentifier.is_none() {
            self.resourceIdentifier = ::std::option::Option::Some(::std::string::String::new());
        }
        self.resourceIdentifier.as_mut().unwrap()
    }

    // Take field
    pub fn take_resourceIdentifier(&mut self) -> ::std::string::String {
        self.resourceIdentifier.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "model",
            |m: &InstanceGeometry| { &m.model },
            |m: &mut InstanceGeometry| { &mut m.model },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "resourceIdentifier",
            |m: &InstanceGeometry| { &m.resourceIdentifier },
            |m: &mut InstanceGeometry| { &mut m.resourceIdentifier },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "position",
            |m: &InstanceGeometry| { &m.position },
            |m: &mut InstanceGeometry| { &mut m.position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "direction",
            |m: &InstanceGeometry| { &m.direction },
            |m: &mut InstanceGeometry| { &mut m.direction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "scale",
            |m: &InstanceGeometry| { &m.scale },
            |m: &mut InstanceGeometry| { &mut m.scale },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Animation>(
            "animation",
            |m: &InstanceGeometry| { &m.animation },
            |m: &mut InstanceGeometry| { &mut m.animation },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InstanceGeometry>(
            "InstanceGeometry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InstanceGeometry {
    const NAME: &'static str = "InstanceGeometry";

    fn is_initialized(&self) -> bool {
        for v in &self.animation {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.model = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.resourceIdentifier = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    is.read_repeated_packed_sint64_into(&mut self.position)?;
                },
                16 => {
                    self.position.push(is.read_sint64()?);
                },
                26 => {
                    is.read_repeated_packed_int32_into(&mut self.direction)?;
                },
                24 => {
                    self.direction.push(is.read_int32()?);
                },
                34 => {
                    is.read_repeated_packed_uint32_into(&mut self.scale)?;
                },
                32 => {
                    self.scale.push(is.read_uint32()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.animation)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.model {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.resourceIdentifier.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::vec_packed_sint64_size(2, &self.position);
        my_size += ::protobuf::rt::vec_packed_int32_size(3, &self.direction);
        my_size += ::protobuf::rt::vec_packed_uint32_size(4, &self.scale);
        if let Some(v) = self.animation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.model {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.resourceIdentifier.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_repeated_packed_sint64(2, &self.position)?;
        os.write_repeated_packed_int32(3, &self.direction)?;
        os.write_repeated_packed_uint32(4, &self.scale)?;
        if let Some(v) = self.animation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InstanceGeometry {
        InstanceGeometry::new()
    }

    fn clear(&mut self) {
        self.model = ::std::option::Option::None;
        self.resourceIdentifier = ::std::option::Option::None;
        self.position.clear();
        self.direction.clear();
        self.scale.clear();
        self.animation.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InstanceGeometry {
        static instance: InstanceGeometry = InstanceGeometry {
            model: ::std::option::Option::None,
            resourceIdentifier: ::std::option::Option::None,
            position: ::std::vec::Vec::new(),
            direction: ::std::vec::Vec::new(),
            scale: ::std::vec::Vec::new(),
            animation: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InstanceGeometry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InstanceGeometry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InstanceGeometry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InstanceGeometry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  The parameters defining an animation.
/// At the moment, this does not support keys yet.
/// Instead, there's an assumption based on the type of animation,
/// e.g. rotations assume that each run of the animation means one full (360) rotation. 
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:frontend_pbf.Animation)
pub struct Animation {
    // message fields
    // @@protoc_insertion_point(field:frontend_pbf.Animation.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<animation::AnimationType>>,
    // @@protoc_insertion_point(field:frontend_pbf.Animation.loopMode)
    pub loopMode: ::std::option::Option<::protobuf::EnumOrUnknown<animation::LoopMode>>,
    // @@protoc_insertion_point(field:frontend_pbf.Animation.timerType)
    pub timerType: ::std::option::Option<::protobuf::EnumOrUnknown<animation::TimerType>>,
    ///  the fraction of the entire animation that is completed each second. 
    // @@protoc_insertion_point(field:frontend_pbf.Animation.runsPerSecond)
    pub runsPerSecond: ::std::option::Option<f64>,
    // special fields
    // @@protoc_insertion_point(special_field:frontend_pbf.Animation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Animation {
    fn default() -> &'a Animation {
        <Animation as ::protobuf::Message>::default_instance()
    }
}

impl Animation {
    pub fn new() -> Animation {
        ::std::default::Default::default()
    }

    // required .frontend_pbf.Animation.AnimationType type = 1;

    pub fn type_(&self) -> animation::AnimationType {
        match self.type_ {
            Some(e) => e.enum_value_or(animation::AnimationType::ROTATION_X),
            None => animation::AnimationType::ROTATION_X,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: animation::AnimationType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .frontend_pbf.Animation.LoopMode loopMode = 2;

    pub fn loopMode(&self) -> animation::LoopMode {
        match self.loopMode {
            Some(e) => e.enum_value_or(animation::LoopMode::CYCLE),
            None => animation::LoopMode::CYCLE,
        }
    }

    pub fn clear_loopMode(&mut self) {
        self.loopMode = ::std::option::Option::None;
    }

    pub fn has_loopMode(&self) -> bool {
        self.loopMode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loopMode(&mut self, v: animation::LoopMode) {
        self.loopMode = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .frontend_pbf.Animation.TimerType timerType = 3;

    pub fn timerType(&self) -> animation::TimerType {
        match self.timerType {
            Some(e) => e.enum_value_or(animation::TimerType::MODEL_TIME),
            None => animation::TimerType::MODEL_TIME,
        }
    }

    pub fn clear_timerType(&mut self) {
        self.timerType = ::std::option::Option::None;
    }

    pub fn has_timerType(&self) -> bool {
        self.timerType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timerType(&mut self, v: animation::TimerType) {
        self.timerType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required double runsPerSecond = 4;

    pub fn runsPerSecond(&self) -> f64 {
        self.runsPerSecond.unwrap_or(0.)
    }

    pub fn clear_runsPerSecond(&mut self) {
        self.runsPerSecond = ::std::option::Option::None;
    }

    pub fn has_runsPerSecond(&self) -> bool {
        self.runsPerSecond.is_some()
    }

    // Param is passed by value, moved
    pub fn set_runsPerSecond(&mut self, v: f64) {
        self.runsPerSecond = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &Animation| { &m.type_ },
            |m: &mut Animation| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "loopMode",
            |m: &Animation| { &m.loopMode },
            |m: &mut Animation| { &mut m.loopMode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timerType",
            |m: &Animation| { &m.timerType },
            |m: &mut Animation| { &mut m.timerType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "runsPerSecond",
            |m: &Animation| { &m.runsPerSecond },
            |m: &mut Animation| { &mut m.runsPerSecond },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Animation>(
            "Animation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Animation {
    const NAME: &'static str = "Animation";

    fn is_initialized(&self) -> bool {
        if self.type_.is_none() {
            return false;
        }
        if self.runsPerSecond.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.loopMode = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.timerType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                33 => {
                    self.runsPerSecond = ::std::option::Option::Some(is.read_double()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.loopMode {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.timerType {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.runsPerSecond {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.loopMode {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.timerType {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.runsPerSecond {
            os.write_double(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Animation {
        Animation::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.loopMode = ::std::option::Option::None;
        self.timerType = ::std::option::Option::None;
        self.runsPerSecond = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Animation {
        static instance: Animation = Animation {
            type_: ::std::option::Option::None,
            loopMode: ::std::option::Option::None,
            timerType: ::std::option::Option::None,
            runsPerSecond: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Animation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Animation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Animation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Animation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Animation`
pub mod animation {
    ///  the property that is being modified 
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:frontend_pbf.Animation.AnimationType)
    pub enum AnimationType {
        // @@protoc_insertion_point(enum_value:frontend_pbf.Animation.AnimationType.ROTATION_X)
        ROTATION_X = 1,
    }

    impl ::protobuf::Enum for AnimationType {
        const NAME: &'static str = "AnimationType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<AnimationType> {
            match value {
                1 => ::std::option::Option::Some(AnimationType::ROTATION_X),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [AnimationType] = &[
            AnimationType::ROTATION_X,
        ];
    }

    impl ::protobuf::EnumFull for AnimationType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Animation.AnimationType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                AnimationType::ROTATION_X => 0,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for AnimationType {
        fn default() -> Self {
            AnimationType::ROTATION_X
        }
    }

    impl AnimationType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<AnimationType>("Animation.AnimationType")
        }
    }

    ///  what happens after the animation completes 
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:frontend_pbf.Animation.LoopMode)
    pub enum LoopMode {
        // @@protoc_insertion_point(enum_value:frontend_pbf.Animation.LoopMode.CYCLE)
        CYCLE = 1,
    }

    impl ::protobuf::Enum for LoopMode {
        const NAME: &'static str = "LoopMode";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<LoopMode> {
            match value {
                1 => ::std::option::Option::Some(LoopMode::CYCLE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [LoopMode] = &[
            LoopMode::CYCLE,
        ];
    }

    impl ::protobuf::EnumFull for LoopMode {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Animation.LoopMode").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                LoopMode::CYCLE => 0,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for LoopMode {
        fn default() -> Self {
            LoopMode::CYCLE
        }
    }

    impl LoopMode {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<LoopMode>("Animation.LoopMode")
        }
    }

    ///  the source of the animation timer.
    /// May eventually be extended to include local time in the simulated location,
    /// animations triggered by user interaction, or factors such as wind direction. 
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:frontend_pbf.Animation.TimerType)
    pub enum TimerType {
        // @@protoc_insertion_point(enum_value:frontend_pbf.Animation.TimerType.MODEL_TIME)
        MODEL_TIME = 1,
    }

    impl ::protobuf::Enum for TimerType {
        const NAME: &'static str = "TimerType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<TimerType> {
            match value {
                1 => ::std::option::Option::Some(TimerType::MODEL_TIME),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [TimerType] = &[
            TimerType::MODEL_TIME,
        ];
    }

    impl ::protobuf::EnumFull for TimerType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Animation.TimerType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                TimerType::MODEL_TIME => 0,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for TimerType {
        fn default() -> Self {
            TimerType::MODEL_TIME
        }
    }

    impl TimerType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<TimerType>("Animation.TimerType")
        }
    }
}

///  a three-dimensional object 
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:frontend_pbf.WorldObject)
pub struct WorldObject {
    // message fields
    ///  the OSM id of the primary element this object is created from, if any 
    // @@protoc_insertion_point(field:frontend_pbf.WorldObject.osmId)
    pub osmId: ::std::option::Option<::std::string::String>,
    ///  the type of this WorldObject, in broad terms. References stringBlock. 
    // @@protoc_insertion_point(field:frontend_pbf.WorldObject.typeName)
    pub typeName: ::std::option::Option<u32>,
    ///  geometry this object is composed of; at least 1 of this or one of the other geometry types is required 
    // @@protoc_insertion_point(field:frontend_pbf.WorldObject.triangleGeometries)
    pub triangleGeometries: ::std::vec::Vec<TriangleGeometry>,
    ///  geometry this object is composed of; at least 1 of this or one of the other geometry types is required 
    // @@protoc_insertion_point(field:frontend_pbf.WorldObject.extrusionGeometries)
    pub extrusionGeometries: ::std::vec::Vec<ExtrusionGeometry>,
    ///  geometry this object is composed of; at least 1 of this or one of the other geometry types is required 
    // @@protoc_insertion_point(field:frontend_pbf.WorldObject.instanceGeometries)
    pub instanceGeometries: ::std::vec::Vec<InstanceGeometry>,
    /// * defines a level of detail (0 to 4) as the lower end of the range where this is visible 
    // @@protoc_insertion_point(field:frontend_pbf.WorldObject.minLod)
    pub minLod: ::std::option::Option<u32>,
    /// * defines a level of detail (0 to 4) as the upper end of the range where this is visible 
    // @@protoc_insertion_point(field:frontend_pbf.WorldObject.maxLod)
    pub maxLod: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:frontend_pbf.WorldObject.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WorldObject {
    fn default() -> &'a WorldObject {
        <WorldObject as ::protobuf::Message>::default_instance()
    }
}

impl WorldObject {
    pub fn new() -> WorldObject {
        ::std::default::Default::default()
    }

    // optional string osmId = 1;

    pub fn osmId(&self) -> &str {
        match self.osmId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_osmId(&mut self) {
        self.osmId = ::std::option::Option::None;
    }

    pub fn has_osmId(&self) -> bool {
        self.osmId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_osmId(&mut self, v: ::std::string::String) {
        self.osmId = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_osmId(&mut self) -> &mut ::std::string::String {
        if self.osmId.is_none() {
            self.osmId = ::std::option::Option::Some(::std::string::String::new());
        }
        self.osmId.as_mut().unwrap()
    }

    // Take field
    pub fn take_osmId(&mut self) -> ::std::string::String {
        self.osmId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 typeName = 2;

    pub fn typeName(&self) -> u32 {
        self.typeName.unwrap_or(0)
    }

    pub fn clear_typeName(&mut self) {
        self.typeName = ::std::option::Option::None;
    }

    pub fn has_typeName(&self) -> bool {
        self.typeName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_typeName(&mut self, v: u32) {
        self.typeName = ::std::option::Option::Some(v);
    }

    // optional uint32 minLod = 6;

    pub fn minLod(&self) -> u32 {
        self.minLod.unwrap_or(0u32)
    }

    pub fn clear_minLod(&mut self) {
        self.minLod = ::std::option::Option::None;
    }

    pub fn has_minLod(&self) -> bool {
        self.minLod.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minLod(&mut self, v: u32) {
        self.minLod = ::std::option::Option::Some(v);
    }

    // optional uint32 maxLod = 7;

    pub fn maxLod(&self) -> u32 {
        self.maxLod.unwrap_or(4u32)
    }

    pub fn clear_maxLod(&mut self) {
        self.maxLod = ::std::option::Option::None;
    }

    pub fn has_maxLod(&self) -> bool {
        self.maxLod.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxLod(&mut self, v: u32) {
        self.maxLod = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "osmId",
            |m: &WorldObject| { &m.osmId },
            |m: &mut WorldObject| { &mut m.osmId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "typeName",
            |m: &WorldObject| { &m.typeName },
            |m: &mut WorldObject| { &mut m.typeName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "triangleGeometries",
            |m: &WorldObject| { &m.triangleGeometries },
            |m: &mut WorldObject| { &mut m.triangleGeometries },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "extrusionGeometries",
            |m: &WorldObject| { &m.extrusionGeometries },
            |m: &mut WorldObject| { &mut m.extrusionGeometries },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "instanceGeometries",
            |m: &WorldObject| { &m.instanceGeometries },
            |m: &mut WorldObject| { &mut m.instanceGeometries },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "minLod",
            |m: &WorldObject| { &m.minLod },
            |m: &mut WorldObject| { &mut m.minLod },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "maxLod",
            |m: &WorldObject| { &m.maxLod },
            |m: &mut WorldObject| { &mut m.maxLod },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WorldObject>(
            "WorldObject",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WorldObject {
    const NAME: &'static str = "WorldObject";

    fn is_initialized(&self) -> bool {
        for v in &self.triangleGeometries {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extrusionGeometries {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.instanceGeometries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.osmId = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.typeName = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.triangleGeometries.push(is.read_message()?);
                },
                34 => {
                    self.extrusionGeometries.push(is.read_message()?);
                },
                42 => {
                    self.instanceGeometries.push(is.read_message()?);
                },
                48 => {
                    self.minLod = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.maxLod = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.osmId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.typeName {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.triangleGeometries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.extrusionGeometries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.instanceGeometries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.minLod {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.maxLod {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.osmId.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.typeName {
            os.write_uint32(2, v)?;
        }
        for v in &self.triangleGeometries {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.extrusionGeometries {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.instanceGeometries {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.minLod {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.maxLod {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WorldObject {
        WorldObject::new()
    }

    fn clear(&mut self) {
        self.osmId = ::std::option::Option::None;
        self.typeName = ::std::option::Option::None;
        self.triangleGeometries.clear();
        self.extrusionGeometries.clear();
        self.instanceGeometries.clear();
        self.minLod = ::std::option::Option::None;
        self.maxLod = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WorldObject {
        static instance: WorldObject = WorldObject {
            osmId: ::std::option::Option::None,
            typeName: ::std::option::Option::None,
            triangleGeometries: ::std::vec::Vec::new(),
            extrusionGeometries: ::std::vec::Vec::new(),
            instanceGeometries: ::std::vec::Vec::new(),
            minLod: ::std::option::Option::None,
            maxLod: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WorldObject {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WorldObject").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WorldObject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WorldObject {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  a tile with 3d data 
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:frontend_pbf.Tile)
pub struct Tile {
    // message fields
    // @@protoc_insertion_point(field:frontend_pbf.Tile.vector3dBlock)
    pub vector3dBlock: ::protobuf::MessageField<Vector3dBlock>,
    // @@protoc_insertion_point(field:frontend_pbf.Tile.vector2dBlock)
    pub vector2dBlock: ::protobuf::MessageField<Vector2dBlock>,
    // @@protoc_insertion_point(field:frontend_pbf.Tile.stringBlock)
    pub stringBlock: ::protobuf::MessageField<StringBlock>,
    // @@protoc_insertion_point(field:frontend_pbf.Tile.shapeBlock)
    pub shapeBlock: ::protobuf::MessageField<ShapeBlock>,
    // @@protoc_insertion_point(field:frontend_pbf.Tile.materialBlock)
    pub materialBlock: ::protobuf::MessageField<MaterialBlock>,
    // @@protoc_insertion_point(field:frontend_pbf.Tile.modelBlock)
    pub modelBlock: ::protobuf::MessageField<ModelBlock>,
    // @@protoc_insertion_point(field:frontend_pbf.Tile.objects)
    pub objects: ::std::vec::Vec<WorldObject>,
    // special fields
    // @@protoc_insertion_point(special_field:frontend_pbf.Tile.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Tile {
    fn default() -> &'a Tile {
        <Tile as ::protobuf::Message>::default_instance()
    }
}

impl Tile {
    pub fn new() -> Tile {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Vector3dBlock>(
            "vector3dBlock",
            |m: &Tile| { &m.vector3dBlock },
            |m: &mut Tile| { &mut m.vector3dBlock },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Vector2dBlock>(
            "vector2dBlock",
            |m: &Tile| { &m.vector2dBlock },
            |m: &mut Tile| { &mut m.vector2dBlock },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StringBlock>(
            "stringBlock",
            |m: &Tile| { &m.stringBlock },
            |m: &mut Tile| { &mut m.stringBlock },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ShapeBlock>(
            "shapeBlock",
            |m: &Tile| { &m.shapeBlock },
            |m: &mut Tile| { &mut m.shapeBlock },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MaterialBlock>(
            "materialBlock",
            |m: &Tile| { &m.materialBlock },
            |m: &mut Tile| { &mut m.materialBlock },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ModelBlock>(
            "modelBlock",
            |m: &Tile| { &m.modelBlock },
            |m: &mut Tile| { &mut m.modelBlock },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "objects",
            |m: &Tile| { &m.objects },
            |m: &mut Tile| { &mut m.objects },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Tile>(
            "Tile",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Tile {
    const NAME: &'static str = "Tile";

    fn is_initialized(&self) -> bool {
        if self.vector3dBlock.is_none() {
            return false;
        }
        if self.vector2dBlock.is_none() {
            return false;
        }
        if self.stringBlock.is_none() {
            return false;
        }
        if self.shapeBlock.is_none() {
            return false;
        }
        if self.materialBlock.is_none() {
            return false;
        }
        if self.modelBlock.is_none() {
            return false;
        }
        for v in &self.vector3dBlock {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.vector2dBlock {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stringBlock {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.shapeBlock {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.materialBlock {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.modelBlock {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.objects {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.vector3dBlock)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.vector2dBlock)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.stringBlock)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.shapeBlock)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.materialBlock)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.modelBlock)?;
                },
                58 => {
                    self.objects.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.vector3dBlock.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.vector2dBlock.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.stringBlock.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.shapeBlock.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.materialBlock.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.modelBlock.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.objects {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.vector3dBlock.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.vector2dBlock.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.stringBlock.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.shapeBlock.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.materialBlock.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.modelBlock.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        for v in &self.objects {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Tile {
        Tile::new()
    }

    fn clear(&mut self) {
        self.vector3dBlock.clear();
        self.vector2dBlock.clear();
        self.stringBlock.clear();
        self.shapeBlock.clear();
        self.materialBlock.clear();
        self.modelBlock.clear();
        self.objects.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Tile {
        static instance: Tile = Tile {
            vector3dBlock: ::protobuf::MessageField::none(),
            vector2dBlock: ::protobuf::MessageField::none(),
            stringBlock: ::protobuf::MessageField::none(),
            shapeBlock: ::protobuf::MessageField::none(),
            materialBlock: ::protobuf::MessageField::none(),
            modelBlock: ::protobuf::MessageField::none(),
            objects: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Tile {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Tile").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Tile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Tile {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x12frontend_v06.proto\x12\x0cfrontend_pbf\"+\n\rVector3dBlock\x12\x1a\
    \n\x06coords\x18\x01\x20\x03(\x12R\x06coordsB\x02\x10\x01\"+\n\rVector2d\
    Block\x12\x1a\n\x06coords\x18\x01\x20\x03(\x12R\x06coordsB\x02\x10\x01\"\
    '\n\x0bStringBlock\x12\x18\n\x07strings\x18\x01\x20\x03(\tR\x07strings\"\
    9\n\nShapeBlock\x12+\n\x06shapes\x18\x01\x20\x03(\x0b2\x13.frontend_pbf.\
    ShapeR\x06shapes\"\x92\x01\n\x05Shape\x121\n\x04type\x18\x01\x20\x02(\
    \x0e2\x1d.frontend_pbf.Shape.ShapeTypeR\x04type\x12\"\n\nparameters\x18\
    \x02\x20\x03(\x12R\nparametersB\x02\x10\x01\"2\n\tShapeType\x12\n\n\x06C\
    IRCLE\x10\x01\x12\x0b\n\x07POLYGON\x10\x02\x12\x0c\n\x08POLYLINE\x10\x03\
    \"E\n\rMaterialBlock\x124\n\tmaterials\x18\x01\x20\x03(\x0b2\x16.fronten\
    d_pbf.MaterialR\tmaterials\"\x9f\x08\n\x08Material\x12\x1e\n\nbaseColorR\
    \x18\x01\x20\x02(\rR\nbaseColorR\x12\x1e\n\nbaseColorG\x18\x02\x20\x02(\
    \rR\nbaseColorG\x12\x1e\n\nbaseColorB\x18\x03\x20\x02(\rR\nbaseColorB\
    \x12G\n\x0ctextureLayer\x18\x0b\x20\x03(\x0b2#.frontend_pbf.Material.Tex\
    tureLayerR\x0ctextureLayer\x12N\n\x0ctransparency\x18\x10\x20\x01(\x0e2#\
    .frontend_pbf.Material.Transparency:\x05FALSER\x0ctransparency\x12$\n\nc\
    astShadow\x18\x11\x20\x01(\x08:\x04trueR\ncastShadow\x12'\n\x0bdoubleSid\
    ed\x18\x12\x20\x01(\x08:\x05falseR\x0bdoubleSided\x1a\x99\x05\n\x0cTextu\
    reLayer\x120\n\x13baseColorTextureURI\x18\x01\x20\x01(\tR\x13baseColorTe\
    xtureURI\x12$\n\rormTextureURI\x18\x07\x20\x01(\tR\rormTextureURI\x12*\n\
    \x10normalTextureURI\x18\x08\x20\x01(\tR\x10normalTextureURI\x126\n\x16d\
    isplacementTextureURI\x18\t\x20\x01(\tR\x16displacementTextureURI\x12.\n\
    \x12emissiveTextureURI\x18\n\x20\x01(\tR\x12emissiveTextureURI\x126\n\
    \x16reflectivityTextureURI\x18\x0b\x20\x01(\tR\x16reflectivityTextureURI\
    \x12D\n\x04wrap\x18\x02\x20\x01(\x0e2(.frontend_pbf.Material.TextureLaye\
    r.Wrap:\x06REPEATR\x04wrap\x12\x1c\n\tcolorable\x18\x03\x20\x02(\x08R\tc\
    olorable\x12\"\n\x0ctextureWidth\x18\x04\x20\x02(\rR\x0ctextureWidth\x12\
    $\n\rtextureHeight\x18\x05\x20\x02(\rR\rtextureHeight\x12h\n\x10texCoord\
    Function\x18\x06\x20\x01(\x0e24.frontend_pbf.Material.TextureLayer.TexCo\
    ordFunction:\x06CUSTOMR\x10texCoordFunction\"\x1d\n\x04Wrap\x12\n\n\x06R\
    EPEAT\x10\x01\x12\t\n\x05CLAMP\x10\x02\".\n\x10TexCoordFunction\x12\n\n\
    \x06CUSTOM\x10\x01\x12\x0e\n\nGLOBAL_X_Z\x10\x02\"/\n\x0cTransparency\
    \x12\x08\n\x04TRUE\x10\x01\x12\n\n\x06BINARY\x10\x02\x12\t\n\x05FALSE\
    \x10\x03\"?\n\nModelBlock\x121\n\x06models\x18\x01\x20\x03(\x0b2\x19.fro\
    ntend_pbf.WorldObjectR\x06models\"p\n\x10TriangleGeometry\x12\x1a\n\x08m\
    aterial\x18\x01\x20\x02(\rR\x08material\x12\x1e\n\x08vertices\x18\x02\
    \x20\x03(\x04R\x08verticesB\x02\x10\x01\x12\x20\n\ttexCoords\x18\x03\x20\
    \x03(\x04R\ttexCoordsB\x02\x10\x01\"\xdd\x01\n\x11ExtrusionGeometry\x12\
    \x1a\n\x08material\x18\x01\x20\x02(\rR\x08material\x12\x14\n\x05shape\
    \x18\x02\x20\x02(\rR\x05shape\x12\x12\n\x04path\x18\x03\x20\x03(\x04R\
    \x04path\x12\x1c\n\tupVectors\x18\x04\x20\x03(\x04R\tupVectors\x12\"\n\
    \x0cscaleFactors\x18\x05\x20\x03(\x04R\x0cscaleFactors\x12!\n\x08startCa\
    p\x18\x07\x20\x01(\x08:\x05falseR\x08startCap\x12\x1d\n\x06endCap\x18\
    \x08\x20\x01(\x08:\x05falseR\x06endCap\"\xeb\x01\n\x10InstanceGeometry\
    \x12\x14\n\x05model\x18\x01\x20\x01(\rR\x05model\x12.\n\x12resourceIdent\
    ifier\x18\x05\x20\x01(\tR\x12resourceIdentifier\x12\x1e\n\x08position\
    \x18\x02\x20\x03(\x12R\x08positionB\x02\x10\x01\x12\x20\n\tdirection\x18\
    \x03\x20\x03(\x05R\tdirectionB\x02\x10\x01\x12\x18\n\x05scale\x18\x04\
    \x20\x03(\rR\x05scaleB\x02\x10\x01\x125\n\tanimation\x18\x06\x20\x01(\
    \x0b2\x17.frontend_pbf.AnimationR\tanimation\"\xd3\x02\n\tAnimation\x129\
    \n\x04type\x18\x01\x20\x02(\x0e2%.frontend_pbf.Animation.AnimationTypeR\
    \x04type\x12C\n\x08loopMode\x18\x02\x20\x01(\x0e2\x20.frontend_pbf.Anima\
    tion.LoopMode:\x05CYCLER\x08loopMode\x12K\n\ttimerType\x18\x03\x20\x01(\
    \x0e2!.frontend_pbf.Animation.TimerType:\nMODEL_TIMER\ttimerType\x12$\n\
    \rrunsPerSecond\x18\x04\x20\x02(\x01R\rrunsPerSecond\"\x1f\n\rAnimationT\
    ype\x12\x0e\n\nROTATION_X\x10\x01\"\x15\n\x08LoopMode\x12\t\n\x05CYCLE\
    \x10\x01\"\x1b\n\tTimerType\x12\x0e\n\nMODEL_TIME\x10\x01\"\xe8\x02\n\
    \x0bWorldObject\x12\x14\n\x05osmId\x18\x01\x20\x01(\tR\x05osmId\x12\x1a\
    \n\x08typeName\x18\x02\x20\x01(\rR\x08typeName\x12N\n\x12triangleGeometr\
    ies\x18\x03\x20\x03(\x0b2\x1e.frontend_pbf.TriangleGeometryR\x12triangle\
    Geometries\x12Q\n\x13extrusionGeometries\x18\x04\x20\x03(\x0b2\x1f.front\
    end_pbf.ExtrusionGeometryR\x13extrusionGeometries\x12N\n\x12instanceGeom\
    etries\x18\x05\x20\x03(\x0b2\x1e.frontend_pbf.InstanceGeometryR\x12insta\
    nceGeometries\x12\x19\n\x06minLod\x18\x06\x20\x01(\r:\x010R\x06minLod\
    \x12\x19\n\x06maxLod\x18\x07\x20\x01(\r:\x014R\x06maxLod\"\xb5\x03\n\x04\
    Tile\x12A\n\rvector3dBlock\x18\x01\x20\x02(\x0b2\x1b.frontend_pbf.Vector\
    3dBlockR\rvector3dBlock\x12A\n\rvector2dBlock\x18\x02\x20\x02(\x0b2\x1b.\
    frontend_pbf.Vector2dBlockR\rvector2dBlock\x12;\n\x0bstringBlock\x18\x03\
    \x20\x02(\x0b2\x19.frontend_pbf.StringBlockR\x0bstringBlock\x128\n\nshap\
    eBlock\x18\x04\x20\x02(\x0b2\x18.frontend_pbf.ShapeBlockR\nshapeBlock\
    \x12A\n\rmaterialBlock\x18\x05\x20\x02(\x0b2\x1b.frontend_pbf.MaterialBl\
    ockR\rmaterialBlock\x128\n\nmodelBlock\x18\x06\x20\x02(\x0b2\x18.fronten\
    d_pbf.ModelBlockR\nmodelBlock\x123\n\x07objects\x18\x07\x20\x03(\x0b2\
    \x19.frontend_pbf.WorldObjectR\x07objectsB5\n&org.osm2world.core.target.\
    frontend_pbfB\x0bFrontendPbfJ\xf4e\n\x07\x12\x05\0\0\xcf\x02\x01\n\x08\n\
    \x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x02\0\x15\n\x08\n\x01\
    \x08\x12\x03\x04\0?\n\t\n\x02\x08\x01\x12\x03\x04\0?\n\x08\n\x01\x08\x12\
    \x03\x05\0,\n\t\n\x02\x08\x08\x12\x03\x05\0,\n\xd2\x02\n\x02\x04\0\x12\
    \x04\x0c\0\x10\x01\x1a\xc5\x02\x20a\x20block\x20containing\x20all\x20thr\
    ee-dimensional\x20vectors\x20used\x20in\x20the\x20tile.\n\x20Vectors\x20\
    are\x20referenced\x20via\x20their\x20position\x20in\x20this\x20block.\n\
    \x20Values\x20are\x20in\x20millimeters\x20relative\x20to\x20the\x20cente\
    r\x20of\x20the\x20tile.\n\x20The\x20first\x203\x20values\x20are\x20x,\
    \x20y,\x20and\x20z\x20coordinates\x20of\x20the\x20first\x20vector,\x20et\
    c.\n\x20Therefore,\x20the\x20number\x20of\x20coordinates\x20must\x20be\
    \x20divisible\x20by\x203.\x20\n\n\n\x03\x04\0\x01\x12\x03\x0c\x08\x15\n\
    \x0b\n\x04\x04\0\x02\0\x12\x03\x0e\x081\n\x0c\n\x05\x04\0\x02\0\x04\x12\
    \x03\x0e\x08\x10\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\x0e\x11\x17\n\x0c\n\
    \x05\x04\0\x02\0\x01\x12\x03\x0e\x18\x1e\n\x0c\n\x05\x04\0\x02\0\x03\x12\
    \x03\x0e!\"\n\x0c\n\x05\x04\0\x02\0\x08\x12\x03\x0e#0\n\r\n\x06\x04\0\
    \x02\0\x08\x02\x12\x03\x0e$/\n\x9a\x01\n\x02\x04\x01\x12\x04\x15\0\x19\
    \x01\x1a\x8d\x01\x20a\x20block\x20containing\x20all\x20two-dimensional\
    \x20vectors\x20used\x20in\x20the\x20tile.\n\x20See\x20Vector3dBlock\x20f\
    or\x20more\x20details.\n\x20All\x20values\x20are\x20multiplied\x20with\
    \x201000.\x20\n\n\n\x03\x04\x01\x01\x12\x03\x15\x08\x15\n\x0b\n\x04\x04\
    \x01\x02\0\x12\x03\x17\x081\n\x0c\n\x05\x04\x01\x02\0\x04\x12\x03\x17\
    \x08\x10\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03\x17\x11\x17\n\x0c\n\x05\
    \x04\x01\x02\0\x01\x12\x03\x17\x18\x1e\n\x0c\n\x05\x04\x01\x02\0\x03\x12\
    \x03\x17!\"\n\x0c\n\x05\x04\x01\x02\0\x08\x12\x03\x17#0\n\r\n\x06\x04\
    \x01\x02\0\x08\x02\x12\x03\x17$/\nJ\n\x02\x04\x02\x12\x04\x1c\0\x20\x01\
    \x1a>\x20a\x20block\x20containing\x20strings\x20referenced\x20elsewhere\
    \x20in\x20the\x20tile.\x20\n\n\n\x03\x04\x02\x01\x12\x03\x1c\x08\x13\n\
    \x0b\n\x04\x04\x02\x02\0\x12\x03\x1e\x08$\n\x0c\n\x05\x04\x02\x02\0\x04\
    \x12\x03\x1e\x08\x10\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03\x1e\x11\x17\n\
    \x0c\n\x05\x04\x02\x02\0\x01\x12\x03\x1e\x18\x1f\n\x0c\n\x05\x04\x02\x02\
    \0\x03\x12\x03\x1e\"#\n@\n\x02\x04\x03\x12\x04#\0'\x01\x1a4\x20a\x20bloc\
    k\x20containing\x20all\x202d\x20shapes\x20used\x20in\x20the\x20tile.\x20\
    \n\n\n\x03\x04\x03\x01\x12\x03#\x08\x12\n\x0b\n\x04\x04\x03\x02\0\x12\
    \x03%\x08\"\n\x0c\n\x05\x04\x03\x02\0\x04\x12\x03%\x08\x10\n\x0c\n\x05\
    \x04\x03\x02\0\x06\x12\x03%\x11\x16\n\x0c\n\x05\x04\x03\x02\0\x01\x12\
    \x03%\x17\x1d\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03%\x20!\n\x18\n\x02\
    \x04\x04\x12\x04*\0C\x01\x1a\x0c\x20a\x202d\x20shape\x20\n\n\n\x03\x04\
    \x04\x01\x12\x03*\x08\r\n\x0c\n\x04\x04\x04\x04\0\x12\x04,\x08;\t\n\x0c\
    \n\x05\x04\x04\x04\0\x01\x12\x03,\r\x16\n\x8c\x01\n\x06\x04\x04\x04\0\
    \x02\0\x12\x033\x10\x1b\x1a}\n\x20a\x20circle.\x20There\x20are\x20only\
    \x20two\x20parameters:\n\x20-\x20the\x20center,\x20as\x20a\x20reference\
    \x20to\x20the\x20vector2dBlock\n\x20-\x20the\x20radius,\x20in\x20millime\
    ters.\n\n\x0e\n\x07\x04\x04\x04\0\x02\0\x01\x12\x033\x10\x16\n\x0e\n\x07\
    \x04\x04\x04\0\x02\0\x02\x12\x033\x19\x1a\n\x90\x01\n\x06\x04\x04\x04\0\
    \x02\x01\x12\x036\x10\x1c\x1a\x80\x01\x20a\x20closed\x20polygon.\x20The\
    \x20parameters\x20represent\x20a\x20series\x20of\x202d\x20vectors\x20(x0\
    ,\x20y0,\x20x1,\x20y1,\x20...).\x20Vector\x20components\x20are\x20in\x20\
    millimeters.\x20\n\x0e\n\x07\x04\x04\x04\0\x02\x01\x01\x12\x036\x10\x17\
    \n\x0e\n\x07\x04\x04\x04\0\x02\x01\x02\x12\x036\x1a\x1b\n\x89\x01\n\x06\
    \x04\x04\x04\0\x02\x02\x12\x039\x10\x1d\x1az\x20a\x20polyline.\x20The\
    \x20parameters\x20represent\x20a\x20series\x20of\x202d\x20vectors\x20(x0\
    ,\x20y0,\x20x1,\x20y1,\x20...).\x20Vector\x20components\x20are\x20in\x20\
    millimeters.\x20\n\x0e\n\x07\x04\x04\x04\0\x02\x02\x01\x12\x039\x10\x18\
    \n\x0e\n\x07\x04\x04\x04\0\x02\x02\x02\x12\x039\x1b\x1c\n\x0b\n\x04\x04\
    \x04\x02\0\x12\x03=\x08$\n\x0c\n\x05\x04\x04\x02\0\x04\x12\x03=\x08\x10\
    \n\x0c\n\x05\x04\x04\x02\0\x06\x12\x03=\x11\x1a\n\x0c\n\x05\x04\x04\x02\
    \0\x01\x12\x03=\x1b\x1f\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03=\"#\nw\n\
    \x04\x04\x04\x02\x01\x12\x03A\x087\x1aj\x20parameters\x20for\x20the\x20s\
    hape,\x20such\x20as\x20the\x20radius\x20of\x20a\x20circle.\nThe\x20preci\
    se\x20meaning\x20depends\x20on\x20the\x20shape\x20type!\x20\n\x0c\n\x05\
    \x04\x04\x02\x01\x04\x12\x03A\x08\x10\n\x0c\n\x05\x04\x04\x02\x01\x05\
    \x12\x03A\x11\x17\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\x03A\x18\"\n\x0c\n\
    \x05\x04\x04\x02\x01\x03\x12\x03A%&\n\x0c\n\x05\x04\x04\x02\x01\x08\x12\
    \x03A'6\n\r\n\x06\x04\x04\x02\x01\x08\x02\x12\x03A(5\n@\n\x02\x04\x05\
    \x12\x04F\0J\x01\x1a4\x20a\x20block\x20containing\x20all\x20materials\
    \x20used\x20in\x20the\x20tile.\x20\n\n\n\x03\x04\x05\x01\x12\x03F\x08\
    \x15\n\x0b\n\x04\x04\x05\x02\0\x12\x03H\x08(\n\x0c\n\x05\x04\x05\x02\0\
    \x04\x12\x03H\x08\x10\n\x0c\n\x05\x04\x05\x02\0\x06\x12\x03H\x11\x19\n\
    \x0c\n\x05\x04\x05\x02\0\x01\x12\x03H\x1a#\n\x0c\n\x05\x04\x05\x02\0\x03\
    \x12\x03H&'\nk\n\x02\x04\x06\x12\x05N\0\xa4\x01\x01\x1a^\x20a\x20set\x20\
    of\x20material\x20properties,\x20using\x20RGB\x20colors.\n\x20Color\x20c\
    omponents\x20are\x20in\x20the\x20range\x20[0,\x20255].\x20\n\n\n\x03\x04\
    \x06\x01\x12\x03N\x08\x10\n\x0c\n\x04\x04\x06\x04\0\x12\x04P\x08[\t\n\
    \x0c\n\x05\x04\x06\x04\0\x01\x12\x03P\r\x19\nO\n\x06\x04\x06\x04\0\x02\0\
    \x12\x03S\x10\x19\x1a@\x20arbitrary\x20transparency,\x20including\x20par\
    tially\x20transparent\x20pixels\x20\n\x0e\n\x07\x04\x06\x04\0\x02\0\x01\
    \x12\x03S\x10\x14\n\x0e\n\x07\x04\x06\x04\0\x02\0\x02\x12\x03S\x17\x18\n\
    Q\n\x06\x04\x06\x04\0\x02\x01\x12\x03V\x10\x1b\x1aB\x20only\x20allow\x20\
    pixels\x20to\x20be\x20either\x20fully\x20transparent\x20or\x20fully\x20o\
    paque\x20\n\x0e\n\x07\x04\x06\x04\0\x02\x01\x01\x12\x03V\x10\x16\n\x0e\n\
    \x07\x04\x06\x04\0\x02\x01\x02\x12\x03V\x19\x1a\n&\n\x06\x04\x06\x04\0\
    \x02\x02\x12\x03Y\x10\x1a\x1a\x17\x20all\x20pixels\x20are\x20opaque\x20\
    \n\x0e\n\x07\x04\x06\x04\0\x02\x02\x01\x12\x03Y\x10\x15\n\x0e\n\x07\x04\
    \x06\x04\0\x02\x02\x02\x12\x03Y\x18\x19\n\x8b\x01\n\x04\x04\x06\x03\0\
    \x12\x05^\x08\x90\x01\t\x1a|*\x20a\x20set\x20of\x20PBR\x20textures\x20re\
    presenting\x20one\x20layer\x20of\x20the\x20material.\x20All\x20textures\
    \x20in\x20the\x20layer\x20use\x20the\x20same\x20texture\x20coordinates.\
    \x20\n\x0c\n\x05\x04\x06\x03\0\x01\x12\x03^\x10\x1c\n\x0e\n\x06\x04\x06\
    \x03\0\x04\0\x12\x04`\x10c\x11\n\x0e\n\x07\x04\x06\x03\0\x04\0\x01\x12\
    \x03`\x15\x19\n\x0f\n\x08\x04\x06\x03\0\x04\0\x02\0\x12\x03a\x18#\n\x10\
    \n\t\x04\x06\x03\0\x04\0\x02\0\x01\x12\x03a\x18\x1e\n\x10\n\t\x04\x06\
    \x03\0\x04\0\x02\0\x02\x12\x03a!\"\n\x0f\n\x08\x04\x06\x03\0\x04\0\x02\
    \x01\x12\x03b\x18\"\n\x10\n\t\x04\x06\x03\0\x04\0\x02\x01\x01\x12\x03b\
    \x18\x1d\n\x10\n\t\x04\x06\x03\0\x04\0\x02\x01\x02\x12\x03b\x20!\n\x0e\n\
    \x06\x04\x06\x03\0\x04\x01\x12\x04e\x10m\x11\n\x0e\n\x07\x04\x06\x03\0\
    \x04\x01\x01\x12\x03e\x15%\n|\n\x08\x04\x06\x03\0\x04\x01\x02\0\x12\x03h\
    \x18#\x1ak\x20No\x20standard\x20function\x20is\x20used.\x20Texture\x20co\
    ordinates\x20for\x20this\x20layer\x20will\x20be\x20provided\x20alongside\
    \x20the\x20geometry.\x20\n\x10\n\t\x04\x06\x03\0\x04\x01\x02\0\x01\x12\
    \x03h\x18\x1e\n\x10\n\t\x04\x06\x03\0\x04\x01\x02\0\x02\x12\x03h!\"\nm\n\
    \x08\x04\x06\x03\0\x04\x01\x02\x01\x12\x03k\x18'\x1a\\\x20uses\x20x\x20a\
    nd\x20z\x20vertex\x20coords\x20together\x20with\x20the\x20texture's\x20w\
    idth\x20and\x20height\x20to\x20place\x20a\x20texture\x20\n\x10\n\t\x04\
    \x06\x03\0\x04\x01\x02\x01\x01\x12\x03k\x18\"\n\x10\n\t\x04\x06\x03\0\
    \x04\x01\x02\x01\x02\x12\x03k%&\n`\n\x06\x04\x06\x03\0\x02\0\x12\x03p\
    \x108\x1aQ\x20URI\x20of\x20the\x20base\x20color\x20+\x20alpha\x20texture\
    \x20image,\x20can\x20be\x20relative,\x20can\x20be\x20a\x20data\x20URI\
    \x20\n\x0e\n\x07\x04\x06\x03\0\x02\0\x04\x12\x03p\x10\x18\n\x0e\n\x07\
    \x04\x06\x03\0\x02\0\x05\x12\x03p\x19\x1f\n\x0e\n\x07\x04\x06\x03\0\x02\
    \0\x01\x12\x03p\x203\n\x0e\n\x07\x04\x06\x03\0\x02\0\x03\x12\x03p67\nk\n\
    \x06\x04\x06\x03\0\x02\x01\x12\x03s\x102\x1a\\\x20URI\x20of\x20the\x20oc\
    clusion/roughness/metalness\x20texture\x20image,\x20can\x20be\x20relativ\
    e,\x20can\x20be\x20a\x20data\x20URI\x20\n\x0e\n\x07\x04\x06\x03\0\x02\
    \x01\x04\x12\x03s\x10\x18\n\x0e\n\x07\x04\x06\x03\0\x02\x01\x05\x12\x03s\
    \x19\x1f\n\x0e\n\x07\x04\x06\x03\0\x02\x01\x01\x12\x03s\x20-\n\x0e\n\x07\
    \x04\x06\x03\0\x02\x01\x03\x12\x03s01\nX\n\x06\x04\x06\x03\0\x02\x02\x12\
    \x03v\x105\x1aI\x20URI\x20of\x20the\x20normal\x20map\x20texture\x20image\
    ,\x20can\x20be\x20relative,\x20can\x20be\x20a\x20data\x20URI\x20\n\x0e\n\
    \x07\x04\x06\x03\0\x02\x02\x04\x12\x03v\x10\x18\n\x0e\n\x07\x04\x06\x03\
    \0\x02\x02\x05\x12\x03v\x19\x1f\n\x0e\n\x07\x04\x06\x03\0\x02\x02\x01\
    \x12\x03v\x200\n\x0e\n\x07\x04\x06\x03\0\x02\x02\x03\x12\x03v34\n^\n\x06\
    \x04\x06\x03\0\x02\x03\x12\x03y\x10;\x1aO\x20URI\x20of\x20the\x20displac\
    ement\x20map\x20texture\x20image,\x20can\x20be\x20relative,\x20can\x20be\
    \x20a\x20data\x20URI\x20\n\x0e\n\x07\x04\x06\x03\0\x02\x03\x04\x12\x03y\
    \x10\x18\n\x0e\n\x07\x04\x06\x03\0\x02\x03\x05\x12\x03y\x19\x1f\n\x0e\n\
    \x07\x04\x06\x03\0\x02\x03\x01\x12\x03y\x206\n\x0e\n\x07\x04\x06\x03\0\
    \x02\x03\x03\x12\x03y9:\nV\n\x06\x04\x06\x03\0\x02\x04\x12\x03|\x108\x1a\
    G\x20URI\x20of\x20the\x20emissive\x20texture\x20image,\x20can\x20be\x20r\
    elative,\x20can\x20be\x20a\x20data\x20URI\x20\n\x0e\n\x07\x04\x06\x03\0\
    \x02\x04\x04\x12\x03|\x10\x18\n\x0e\n\x07\x04\x06\x03\0\x02\x04\x05\x12\
    \x03|\x19\x1f\n\x0e\n\x07\x04\x06\x03\0\x02\x04\x01\x12\x03|\x202\n\x0e\
    \n\x07\x04\x06\x03\0\x02\x04\x03\x12\x03|57\nZ\n\x06\x04\x06\x03\0\x02\
    \x05\x12\x03\x7f\x10<\x1aK\x20URI\x20of\x20the\x20reflectivity\x20textur\
    e\x20image,\x20can\x20be\x20relative,\x20can\x20be\x20a\x20data\x20URI\
    \x20\n\x0e\n\x07\x04\x06\x03\0\x02\x05\x04\x12\x03\x7f\x10\x18\n\x0e\n\
    \x07\x04\x06\x03\0\x02\x05\x05\x12\x03\x7f\x19\x1f\n\x0e\n\x07\x04\x06\
    \x03\0\x02\x05\x01\x12\x03\x7f\x206\n\x0e\n\x07\x04\x06\x03\0\x02\x05\
    \x03\x12\x03\x7f9;\n`\n\x06\x04\x06\x03\0\x02\x06\x12\x04\x83\x01\x10:\
    \x1aP\x20how\x20the\x20texture\x20behaves\x20for\x20texture\x20coordinat\
    es\n\x20less\x20than\x200\x20or\x20greater\x20than\x201\x20\n\x0f\n\x07\
    \x04\x06\x03\0\x02\x06\x04\x12\x04\x83\x01\x10\x18\n\x0f\n\x07\x04\x06\
    \x03\0\x02\x06\x06\x12\x04\x83\x01\x19\x1d\n\x0f\n\x07\x04\x06\x03\0\x02\
    \x06\x01\x12\x04\x83\x01\x1e\"\n\x0f\n\x07\x04\x06\x03\0\x02\x06\x03\x12\
    \x04\x83\x01%&\n\x0f\n\x07\x04\x06\x03\0\x02\x06\x08\x12\x04\x83\x01'9\n\
    \x0f\n\x07\x04\x06\x03\0\x02\x06\x07\x12\x04\x83\x0128\nj\n\x06\x04\x06\
    \x03\0\x02\x07\x12\x04\x86\x01\x10,\x1aZ\x20whether\x20the\x20base\x20co\
    lor\x20texture\x20should\x20be\x20multiplied\x20with\x20the\x20material'\
    s\x20base\x20color\x20value\x20\n\x0f\n\x07\x04\x06\x03\0\x02\x07\x04\
    \x12\x04\x86\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\0\x02\x07\x05\x12\x04\
    \x86\x01\x19\x1d\n\x0f\n\x07\x04\x06\x03\0\x02\x07\x01\x12\x04\x86\x01\
    \x1e'\n\x0f\n\x07\x04\x06\x03\0\x02\x07\x03\x12\x04\x86\x01*+\n6\n\x06\
    \x04\x06\x03\0\x02\x08\x12\x04\x89\x01\x101\x1a&\x20width\x20of\x20the\
    \x20texture\x20in\x20millimeters.\x20\n\x0f\n\x07\x04\x06\x03\0\x02\x08\
    \x04\x12\x04\x89\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\0\x02\x08\x05\x12\
    \x04\x89\x01\x19\x1f\n\x0f\n\x07\x04\x06\x03\0\x02\x08\x01\x12\x04\x89\
    \x01\x20,\n\x0f\n\x07\x04\x06\x03\0\x02\x08\x03\x12\x04\x89\x01/0\n7\n\
    \x06\x04\x06\x03\0\x02\t\x12\x04\x8c\x01\x102\x1a'\x20height\x20of\x20th\
    e\x20texture\x20in\x20millimeters.\x20\n\x0f\n\x07\x04\x06\x03\0\x02\t\
    \x04\x12\x04\x8c\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\0\x02\t\x05\x12\x04\
    \x8c\x01\x19\x1f\n\x0f\n\x07\x04\x06\x03\0\x02\t\x01\x12\x04\x8c\x01\x20\
    -\n\x0f\n\x07\x04\x06\x03\0\x02\t\x03\x12\x04\x8c\x0101\n\x0e\n\x06\x04\
    \x06\x03\0\x02\n\x12\x04\x8e\x01\x10R\n\x0f\n\x07\x04\x06\x03\0\x02\n\
    \x04\x12\x04\x8e\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\0\x02\n\x06\x12\x04\
    \x8e\x01\x19)\n\x0f\n\x07\x04\x06\x03\0\x02\n\x01\x12\x04\x8e\x01*:\n\
    \x0f\n\x07\x04\x06\x03\0\x02\n\x03\x12\x04\x8e\x01=>\n\x0f\n\x07\x04\x06\
    \x03\0\x02\n\x08\x12\x04\x8e\x01?Q\n\x0f\n\x07\x04\x06\x03\0\x02\n\x07\
    \x12\x04\x8e\x01JP\n\x0c\n\x04\x04\x06\x02\0\x12\x04\x92\x01\x08'\n\r\n\
    \x05\x04\x06\x02\0\x04\x12\x04\x92\x01\x08\x10\n\r\n\x05\x04\x06\x02\0\
    \x05\x12\x04\x92\x01\x11\x17\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\x92\x01\
    \x18\"\n\r\n\x05\x04\x06\x02\0\x03\x12\x04\x92\x01%&\n\x0c\n\x04\x04\x06\
    \x02\x01\x12\x04\x93\x01\x08'\n\r\n\x05\x04\x06\x02\x01\x04\x12\x04\x93\
    \x01\x08\x10\n\r\n\x05\x04\x06\x02\x01\x05\x12\x04\x93\x01\x11\x17\n\r\n\
    \x05\x04\x06\x02\x01\x01\x12\x04\x93\x01\x18\"\n\r\n\x05\x04\x06\x02\x01\
    \x03\x12\x04\x93\x01%&\n\x0c\n\x04\x04\x06\x02\x02\x12\x04\x94\x01\x08'\
    \n\r\n\x05\x04\x06\x02\x02\x04\x12\x04\x94\x01\x08\x10\n\r\n\x05\x04\x06\
    \x02\x02\x05\x12\x04\x94\x01\x11\x17\n\r\n\x05\x04\x06\x02\x02\x01\x12\
    \x04\x94\x01\x18\"\n\r\n\x05\x04\x06\x02\x02\x03\x12\x04\x94\x01%&\n:\n\
    \x04\x04\x06\x02\x03\x12\x04\x97\x01\x080\x1a,\x20texture\x20layers,\x20\
    ordered\x20from\x20bottom\x20to\x20top\x20\n\r\n\x05\x04\x06\x02\x03\x04\
    \x12\x04\x97\x01\x08\x10\n\r\n\x05\x04\x06\x02\x03\x06\x12\x04\x97\x01\
    \x11\x1d\n\r\n\x05\x04\x06\x02\x03\x01\x12\x04\x97\x01\x1e*\n\r\n\x05\
    \x04\x06\x02\x03\x03\x12\x04\x97\x01-/\n(\n\x04\x04\x06\x02\x04\x12\x04\
    \x9a\x01\x08B\x1a\x1a\x20the\x20type\x20of\x20transparency\x20\n\r\n\x05\
    \x04\x06\x02\x04\x04\x12\x04\x9a\x01\x08\x10\n\r\n\x05\x04\x06\x02\x04\
    \x06\x12\x04\x9a\x01\x11\x1d\n\r\n\x05\x04\x06\x02\x04\x01\x12\x04\x9a\
    \x01\x1e*\n\r\n\x05\x04\x06\x02\x04\x03\x12\x04\x9a\x01-/\n\r\n\x05\x04\
    \x06\x02\x04\x08\x12\x04\x9a\x010A\n\r\n\x05\x04\x06\x02\x04\x07\x12\x04\
    \x9a\x01;@\n3\n\x04\x04\x06\x02\x05\x12\x04\x9d\x01\x087\x1a%\x20whether\
    \x20this\x20material\x20casts\x20shadows\x20\n\r\n\x05\x04\x06\x02\x05\
    \x04\x12\x04\x9d\x01\x08\x10\n\r\n\x05\x04\x06\x02\x05\x05\x12\x04\x9d\
    \x01\x11\x15\n\r\n\x05\x04\x06\x02\x05\x01\x12\x04\x9d\x01\x16\x20\n\r\n\
    \x05\x04\x06\x02\x05\x03\x12\x04\x9d\x01#%\n\r\n\x05\x04\x06\x02\x05\x08\
    \x12\x04\x9d\x01&6\n\r\n\x05\x04\x06\x02\x05\x07\x12\x04\x9d\x0115\n\x91\
    \x01\n\x04\x04\x06\x02\x06\x12\x04\xa2\x01\x089\x1a\x82\x01\x20whether\
    \x20this\x20material\x20is\x20double-sided.\n\x20If\x20true,\x20backface\
    \x20culling\x20should\x20be\x20disabled,\n\x20and\x20two-sided\x20lighti\
    ng\x20should\x20be\x20enabled.\x20\n\r\n\x05\x04\x06\x02\x06\x04\x12\x04\
    \xa2\x01\x08\x10\n\r\n\x05\x04\x06\x02\x06\x05\x12\x04\xa2\x01\x11\x15\n\
    \r\n\x05\x04\x06\x02\x06\x01\x12\x04\xa2\x01\x16!\n\r\n\x05\x04\x06\x02\
    \x06\x03\x12\x04\xa2\x01$&\n\r\n\x05\x04\x06\x02\x06\x08\x12\x04\xa2\x01\
    '8\n\r\n\x05\x04\x06\x02\x06\x07\x12\x04\xa2\x0127\n\xc2\x01\n\x02\x04\
    \x07\x12\x06\xa9\x01\0\xae\x01\x01\x1a\xb3\x01\x20a\x20block\x20containi\
    ng\x20all\x20template\x20models\x20used\x20in\x20this\x20file.\n\x20Each\
    \x20model\x20is\x20represented\x20as\x20a\x20WorldObject\x20with\x20no\
    \x20id\x20or\x20type.\n\x20A\x20template\x20model\x20must\x20not\x20use\
    \x20InstanceGeometry\x20itself.\x20\n\x0b\n\x03\x04\x07\x01\x12\x04\xa9\
    \x01\x08\x12\ne\n\x04\x04\x07\x02\0\x12\x04\xac\x01\x08(\x1aW\x20the\x20\
    template\x20models\x20that\x20can\x20be\x20copied\x20(with\x20slight\x20\
    variations)\x20in\x20multiple\x20locations\x20\n\r\n\x05\x04\x07\x02\0\
    \x04\x12\x04\xac\x01\x08\x10\n\r\n\x05\x04\x07\x02\0\x06\x12\x04\xac\x01\
    \x11\x1c\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\xac\x01\x1d#\n\r\n\x05\x04\
    \x07\x02\0\x03\x12\x04\xac\x01&'\n9\n\x02\x04\x08\x12\x06\xb1\x01\0\xc4\
    \x01\x01\x1a+\x20geometry\x20consisting\x20of\x20a\x20set\x20of\x20trian\
    gles\x20\n\x0b\n\x03\x04\x08\x01\x12\x04\xb1\x01\x08\x18\nB\n\x04\x04\
    \x08\x02\0\x12\x04\xb4\x01\x08%\x1a4\x20the\x20geometry's\x20material,\
    \x20referencing\x20materialBlock\x20\n\r\n\x05\x04\x08\x02\0\x04\x12\x04\
    \xb4\x01\x08\x10\n\r\n\x05\x04\x08\x02\0\x05\x12\x04\xb4\x01\x11\x17\n\r\
    \n\x05\x04\x08\x02\0\x01\x12\x04\xb4\x01\x18\x20\n\r\n\x05\x04\x08\x02\0\
    \x03\x12\x04\xb4\x01#$\n\x9e\x01\n\x04\x04\x08\x02\x01\x12\x04\xb9\x01\
    \x085\x1a\x8f\x01\x20vertices\x20of\x20the\x20triangles,\x20represented\
    \x20as\n\x203\x20references\x20to\x20the\x20Vector3d\x20block\x20each.\n\
    \x20At\x20least\x201\x20triangle\x20(i.e.\x203\x20vertex\x20references)\
    \x20required.\x20\n\r\n\x05\x04\x08\x02\x01\x04\x12\x04\xb9\x01\x08\x10\
    \n\r\n\x05\x04\x08\x02\x01\x05\x12\x04\xb9\x01\x11\x17\n\r\n\x05\x04\x08\
    \x02\x01\x01\x12\x04\xb9\x01\x18\x20\n\r\n\x05\x04\x08\x02\x01\x03\x12\
    \x04\xb9\x01#$\n\r\n\x05\x04\x08\x02\x01\x08\x12\x04\xb9\x01%4\n\x0e\n\
    \x06\x04\x08\x02\x01\x08\x02\x12\x04\xb9\x01&3\n\x8c\x03\n\x04\x04\x08\
    \x02\x02\x12\x04\xc2\x01\x086\x1a\xfd\x02\x20texture\x20coordinates\x20f\
    or\x20each\x20vertex\x20of\x20the\x20triangles,\n\x20referencing\x20the\
    \x20Vector2d\x20block.\n\x20Texture\x20coordinates\x20are\x20only\x20pro\
    vided\x20for\x20those\x20layers\n\x20which\x20are\x20using\x20the\x20CUS\
    TOM\x20texture\x20coordinate\x20function\x20(see\x20Material).\n\x20The\
    \x20length\x20of\x20this\x20list\x20is\x20that\x20of\n\x20vertices,\x20t\
    imes\x20the\x20number\x20of\x20CUSTOM-coordinated\x20texture\x20layers.\
    \n\x20Starts\x20with\x20all\x20vertices'\x20tex\x20coords\x20for\x20laye\
    r\x200,\x20then\x201\x20etc.\x20\n\r\n\x05\x04\x08\x02\x02\x04\x12\x04\
    \xc2\x01\x08\x10\n\r\n\x05\x04\x08\x02\x02\x05\x12\x04\xc2\x01\x11\x17\n\
    \r\n\x05\x04\x08\x02\x02\x01\x12\x04\xc2\x01\x18!\n\r\n\x05\x04\x08\x02\
    \x02\x03\x12\x04\xc2\x01$%\n\r\n\x05\x04\x08\x02\x02\x08\x12\x04\xc2\x01\
    &5\n\x0e\n\x06\x04\x08\x02\x02\x08\x02\x12\x04\xc2\x01'4\n\x90\x01\n\x02\
    \x04\t\x12\x06\xc8\x01\0\xdc\x01\x01\x1a\x81\x01\x20geometry\x20produced\
    \x20by\x20extruding\x20a\x202d\x20shape.\nSee\x20OSM2World's\x20Target.d\
    rawExtrudedShape\x20method\x20for\x20documentation\x20of\x20the\x20param\
    eters.\x20\n\x0b\n\x03\x04\t\x01\x12\x04\xc8\x01\x08\x19\nB\n\x04\x04\t\
    \x02\0\x12\x04\xcb\x01\x08%\x1a4\x20the\x20geometry's\x20material,\x20re\
    ferencing\x20materialBlock\x20\n\r\n\x05\x04\t\x02\0\x04\x12\x04\xcb\x01\
    \x08\x10\n\r\n\x05\x04\t\x02\0\x05\x12\x04\xcb\x01\x11\x17\n\r\n\x05\x04\
    \t\x02\0\x01\x12\x04\xcb\x01\x18\x20\n\r\n\x05\x04\t\x02\0\x03\x12\x04\
    \xcb\x01#$\n@\n\x04\x04\t\x02\x01\x12\x04\xce\x01\x08\"\x1a2\x20the\x20s\
    hape\x20to\x20be\x20extruded,\x20referencing\x20shapeBlock\x20\n\r\n\x05\
    \x04\t\x02\x01\x04\x12\x04\xce\x01\x08\x10\n\r\n\x05\x04\t\x02\x01\x05\
    \x12\x04\xce\x01\x11\x17\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\xce\x01\x18\
    \x1d\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\xce\x01\x20!\n)\n\x04\x04\t\x02\
    \x02\x12\x04\xd1\x01\x08!\x1a\x1b\x20referencing\x20vector3dBlock\x20\n\
    \r\n\x05\x04\t\x02\x02\x04\x12\x04\xd1\x01\x08\x10\n\r\n\x05\x04\t\x02\
    \x02\x05\x12\x04\xd1\x01\x11\x17\n\r\n\x05\x04\t\x02\x02\x01\x12\x04\xd1\
    \x01\x18\x1c\n\r\n\x05\x04\t\x02\x02\x03\x12\x04\xd1\x01\x1f\x20\nj\n\
    \x04\x04\t\x02\x03\x12\x04\xd4\x01\x08&\x1a\\\x20referencing\x20vector3d\
    Block.\x20Same\x20length\x20as\x20path.\x20Can\x20be\x20omitted,\x20defa\
    ults\x20to\x20z\x20unit\x20vector.\x20\n\r\n\x05\x04\t\x02\x03\x04\x12\
    \x04\xd4\x01\x08\x10\n\r\n\x05\x04\t\x02\x03\x05\x12\x04\xd4\x01\x11\x17\
    \n\r\n\x05\x04\t\x02\x03\x01\x12\x04\xd4\x01\x18!\n\r\n\x05\x04\t\x02\
    \x03\x03\x12\x04\xd4\x01$%\nt\n\x04\x04\t\x02\x04\x12\x04\xd7\x01\x08)\
    \x1af\x20multiplicative\x20factor,\x20times\x201000.\x20Either\x20omitte\
    d\x20(if\x20no\x20scaling\x20is\x20applied)\x20or\x20same\x20length\x20a\
    s\x20path.\x20\n\r\n\x05\x04\t\x02\x04\x04\x12\x04\xd7\x01\x08\x10\n\r\n\
    \x05\x04\t\x02\x04\x05\x12\x04\xd7\x01\x11\x17\n\r\n\x05\x04\t\x02\x04\
    \x01\x12\x04\xd7\x01\x18$\n\r\n\x05\x04\t\x02\x04\x03\x12\x04\xd7\x01'(\
    \n\x0c\n\x04\x04\t\x02\x05\x12\x04\xd9\x01\x085\n\r\n\x05\x04\t\x02\x05\
    \x04\x12\x04\xd9\x01\x08\x10\n\r\n\x05\x04\t\x02\x05\x05\x12\x04\xd9\x01\
    \x11\x15\n\r\n\x05\x04\t\x02\x05\x01\x12\x04\xd9\x01\x16\x1e\n\r\n\x05\
    \x04\t\x02\x05\x03\x12\x04\xd9\x01!\"\n\r\n\x05\x04\t\x02\x05\x08\x12\
    \x04\xd9\x01#4\n\r\n\x05\x04\t\x02\x05\x07\x12\x04\xd9\x01.3\n\x0c\n\x04\
    \x04\t\x02\x06\x12\x04\xda\x01\x083\n\r\n\x05\x04\t\x02\x06\x04\x12\x04\
    \xda\x01\x08\x10\n\r\n\x05\x04\t\x02\x06\x05\x12\x04\xda\x01\x11\x15\n\r\
    \n\x05\x04\t\x02\x06\x01\x12\x04\xda\x01\x16\x1c\n\r\n\x05\x04\t\x02\x06\
    \x03\x12\x04\xda\x01\x1f\x20\n\r\n\x05\x04\t\x02\x06\x08\x12\x04\xda\x01\
    !2\n\r\n\x05\x04\t\x02\x06\x07\x12\x04\xda\x01,1\nK\n\x02\x04\n\x12\x06\
    \xdf\x01\0\xf9\x01\x01\x1a=\x20copies\x20of\x20some\x20prototype\x20mode\
    l,\x20possibly\x20rotated\x20and\x20scaled\x20\n\x0b\n\x03\x04\n\x01\x12\
    \x04\xdf\x01\x08\x18\n\x91\x01\n\x04\x04\n\x02\0\x12\x04\xe3\x01\x08\"\
    \x1a\x82\x01\x20the\x20prototype\x20model,\x20referencing\x20the\x20mode\
    lBlock.\nAlternatively,\x20an\x20external\x20resource\x20can\x20be\x20re\
    ferenced\x20using\x20resourceIdentifier.\x20\n\r\n\x05\x04\n\x02\0\x04\
    \x12\x04\xe3\x01\x08\x10\n\r\n\x05\x04\n\x02\0\x05\x12\x04\xe3\x01\x11\
    \x17\n\r\n\x05\x04\n\x02\0\x01\x12\x04\xe3\x01\x18\x1d\n\r\n\x05\x04\n\
    \x02\0\x03\x12\x04\xe3\x01\x20!\n\xc7\x01\n\x04\x04\n\x02\x01\x12\x04\
    \xe7\x01\x08/\x1a\xb8\x01\x20string\x20identifying\x20an\x20external\x20\
    model\x20in\x20some\x20way,\x20e.g.\x20as\x20an\x20URI\x20or\x20a\x20str\
    ing\x20constant.\nAlternatively,\x20a\x20prototype\x20model\x20included\
    \x20in\x20this\x20file\x20can\x20be\x20referenced\x20using\x20the\x20mod\
    el\x20field.\x20\n\r\n\x05\x04\n\x02\x01\x04\x12\x04\xe7\x01\x08\x10\n\r\
    \n\x05\x04\n\x02\x01\x05\x12\x04\xe7\x01\x11\x17\n\r\n\x05\x04\n\x02\x01\
    \x01\x12\x04\xe7\x01\x18*\n\r\n\x05\x04\n\x02\x01\x03\x12\x04\xe7\x01-.\
    \n\xbb\x01\n\x04\x04\n\x02\x02\x12\x04\xec\x01\x083\x1a\xac\x01\x20posit\
    ion\x20of\x20each\x20instance.\nValues\x20are\x20in\x20millimeters\x20re\
    lative\x20to\x20the\x20center\x20of\x20the\x20tile\x20(like\x20Vector3dB\
    lock).\nEach\x20position\x20is\x20represented\x20as\x20an\x20x,\x20y,\
    \x20z\x20triple\x20of\x20values.\x20\n\r\n\x05\x04\n\x02\x02\x04\x12\x04\
    \xec\x01\x08\x10\n\r\n\x05\x04\n\x02\x02\x05\x12\x04\xec\x01\x11\x17\n\r\
    \n\x05\x04\n\x02\x02\x01\x12\x04\xec\x01\x18\x20\n\r\n\x05\x04\n\x02\x02\
    \x03\x12\x04\xec\x01#$\n\r\n\x05\x04\n\x02\x02\x08\x12\x04\xec\x01%2\n\
    \x0e\n\x06\x04\n\x02\x02\x08\x02\x12\x04\xec\x01&1\n\xab\x01\n\x04\x04\n\
    \x02\x03\x12\x04\xf0\x01\x083\x1a\x9c\x01\x20rotation\x20angle\x20around\
    \x20the\x20y\x20axis\x20for\x20each\x20instance\x20in\x20milliradians,\
    \x20clockwise.\nEither\x20one\x20third\x20of\x20the\x20length\x20of\x20'\
    position'\x20or\x20empty\x20(for\x20a\x20default\x20of\x200).\x20\n\r\n\
    \x05\x04\n\x02\x03\x04\x12\x04\xf0\x01\x08\x10\n\r\n\x05\x04\n\x02\x03\
    \x05\x12\x04\xf0\x01\x11\x16\n\r\n\x05\x04\n\x02\x03\x01\x12\x04\xf0\x01\
    \x17\x20\n\r\n\x05\x04\n\x02\x03\x03\x12\x04\xf0\x01#$\n\r\n\x05\x04\n\
    \x02\x03\x08\x12\x04\xf0\x01%2\n\x0e\n\x06\x04\n\x02\x03\x08\x02\x12\x04\
    \xf0\x01&1\n\x85\x01\n\x04\x04\n\x02\x04\x12\x04\xf4\x01\x080\x1aw\x20sc\
    ale\x20factor\x20for\x20each\x20instance\x20in\x201/1000.\nEither\x20one\
    \x20third\x20of\x20the\x20length\x20of\x20'position'\x20or\x20empty\x20(\
    for\x20a\x20default\x20of\x201).\x20\n\r\n\x05\x04\n\x02\x04\x04\x12\x04\
    \xf4\x01\x08\x10\n\r\n\x05\x04\n\x02\x04\x05\x12\x04\xf4\x01\x11\x17\n\r\
    \n\x05\x04\n\x02\x04\x01\x12\x04\xf4\x01\x18\x1d\n\r\n\x05\x04\n\x02\x04\
    \x03\x12\x04\xf4\x01\x20!\n\r\n\x05\x04\n\x02\x04\x08\x12\x04\xf4\x01\"/\
    \n\x0e\n\x06\x04\n\x02\x04\x08\x02\x12\x04\xf4\x01#.\nD\n\x04\x04\n\x02\
    \x05\x12\x04\xf7\x01\x08)\x1a6\x20this\x20message\x20is\x20present\x20if\
    \x20this\x20geometry\x20is\x20animated\x20\n\r\n\x05\x04\n\x02\x05\x04\
    \x12\x04\xf7\x01\x08\x10\n\r\n\x05\x04\n\x02\x05\x06\x12\x04\xf7\x01\x11\
    \x1a\n\r\n\x05\x04\n\x02\x05\x01\x12\x04\xf7\x01\x1b$\n\r\n\x05\x04\n\
    \x02\x05\x03\x12\x04\xf7\x01'(\n\xfa\x01\n\x02\x04\x0b\x12\x06\xff\x01\0\
    \xa7\x02\x01\x1a\xeb\x01\x20The\x20parameters\x20defining\x20an\x20anima\
    tion.\nAt\x20the\x20moment,\x20this\x20does\x20not\x20support\x20keys\
    \x20yet.\nInstead,\x20there's\x20an\x20assumption\x20based\x20on\x20the\
    \x20type\x20of\x20animation,\ne.g.\x20rotations\x20assume\x20that\x20eac\
    h\x20run\x20of\x20the\x20animation\x20means\x20one\x20full\x20(360\xc2\
    \xb0)\x20rotation.\x20\n\x0b\n\x03\x04\x0b\x01\x12\x04\xff\x01\x08\x11\n\
    5\n\x04\x04\x0b\x04\0\x12\x06\x82\x02\x08\x88\x02\t\x1a%\x20the\x20prope\
    rty\x20that\x20is\x20being\x20modified\x20\n\r\n\x05\x04\x0b\x04\0\x01\
    \x12\x04\x82\x02\r\x1a\n|\n\x06\x04\x0b\x04\0\x02\0\x12\x04\x86\x02\x10\
    \x1f\x1al\x20clockwise\x20rotation\x20around\x20the\x20model's\x20local\
    \x20x\x20axis\n(before\x20InstanceGeometry's\x20transformations\x20are\
    \x20applied)\x20\n\x0f\n\x07\x04\x0b\x04\0\x02\0\x01\x12\x04\x86\x02\x10\
    \x1a\n\x0f\n\x07\x04\x0b\x04\0\x02\0\x02\x12\x04\x86\x02\x1d\x1e\n<\n\
    \x04\x04\x0b\x04\x01\x12\x06\x8b\x02\x08\x91\x02\t\x1a,\x20what\x20happe\
    ns\x20after\x20the\x20animation\x20completes\x20\n\r\n\x05\x04\x0b\x04\
    \x01\x01\x12\x04\x8b\x02\r\x15\n\x89\x01\n\x06\x04\x0b\x04\x01\x02\0\x12\
    \x04\x8f\x02\x10\x1a\x1ay\x20restart\x20the\x20animation\x20from\x20the\
    \x20beginning.\nRemaining\x20progress\x20should\x20be\x20used\x20in\x20t\
    he\x20next\x20cycle\x20(i.e.\x20modulo-style\x20wrap).\x20\n\x0f\n\x07\
    \x04\x0b\x04\x01\x02\0\x01\x12\x04\x8f\x02\x10\x15\n\x0f\n\x07\x04\x0b\
    \x04\x01\x02\0\x02\x12\x04\x8f\x02\x18\x19\n\xce\x01\n\x04\x04\x0b\x04\
    \x02\x12\x06\x96\x02\x08\x9c\x02\t\x1a\xbd\x01\x20the\x20source\x20of\
    \x20the\x20animation\x20timer.\nMay\x20eventually\x20be\x20extended\x20t\
    o\x20include\x20local\x20time\x20in\x20the\x20simulated\x20location,\nan\
    imations\x20triggered\x20by\x20user\x20interaction,\x20or\x20factors\x20\
    such\x20as\x20wind\x20direction.\x20\n\r\n\x05\x04\x0b\x04\x02\x01\x12\
    \x04\x96\x02\r\x16\n\xa5\x01\n\x06\x04\x0b\x04\x02\x02\0\x12\x04\x9a\x02\
    \x10\x1f\x1a\x94\x01\x20A\x20clock\x20counting\x20seconds\x20with\x20arb\
    itrary\x20starting\x20point.\nCan\x20even\x20be\x20started\x20at\x20diff\
    erent\x20values\x20for\x20different\x20models\x20to\x20prevent\x20synced\
    \x20animations.\x20\n\x0f\n\x07\x04\x0b\x04\x02\x02\0\x01\x12\x04\x9a\
    \x02\x10\x1a\n\x0f\n\x07\x04\x0b\x04\x02\x02\0\x02\x12\x04\x9a\x02\x1d\
    \x1e\n\x0c\n\x04\x04\x0b\x02\0\x12\x04\x9e\x02\x08(\n\r\n\x05\x04\x0b\
    \x02\0\x04\x12\x04\x9e\x02\x08\x10\n\r\n\x05\x04\x0b\x02\0\x06\x12\x04\
    \x9e\x02\x11\x1e\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\x9e\x02\x1f#\n\r\n\
    \x05\x04\x0b\x02\0\x03\x12\x04\x9e\x02&'\n\x0c\n\x04\x04\x0b\x02\x01\x12\
    \x04\xa0\x02\x089\n\r\n\x05\x04\x0b\x02\x01\x04\x12\x04\xa0\x02\x08\x10\
    \n\r\n\x05\x04\x0b\x02\x01\x06\x12\x04\xa0\x02\x11\x19\n\r\n\x05\x04\x0b\
    \x02\x01\x01\x12\x04\xa0\x02\x1a\"\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\
    \xa0\x02%&\n\r\n\x05\x04\x0b\x02\x01\x08\x12\x04\xa0\x02'8\n\r\n\x05\x04\
    \x0b\x02\x01\x07\x12\x04\xa0\x0227\n\x0c\n\x04\x04\x0b\x02\x02\x12\x04\
    \xa2\x02\x08@\n\r\n\x05\x04\x0b\x02\x02\x04\x12\x04\xa2\x02\x08\x10\n\r\
    \n\x05\x04\x0b\x02\x02\x06\x12\x04\xa2\x02\x11\x1a\n\r\n\x05\x04\x0b\x02\
    \x02\x01\x12\x04\xa2\x02\x1b$\n\r\n\x05\x04\x0b\x02\x02\x03\x12\x04\xa2\
    \x02'(\n\r\n\x05\x04\x0b\x02\x02\x08\x12\x04\xa2\x02)?\n\r\n\x05\x04\x0b\
    \x02\x02\x07\x12\x04\xa2\x024>\nS\n\x04\x04\x0b\x02\x03\x12\x04\xa5\x02\
    \x08*\x1aE\x20the\x20fraction\x20of\x20the\x20entire\x20animation\x20tha\
    t\x20is\x20completed\x20each\x20second.\x20\n\r\n\x05\x04\x0b\x02\x03\
    \x04\x12\x04\xa5\x02\x08\x10\n\r\n\x05\x04\x0b\x02\x03\x05\x12\x04\xa5\
    \x02\x11\x17\n\r\n\x05\x04\x0b\x02\x03\x01\x12\x04\xa5\x02\x18%\n\r\n\
    \x05\x04\x0b\x02\x03\x03\x12\x04\xa5\x02()\n*\n\x02\x04\x0c\x12\x06\xaa\
    \x02\0\xc1\x02\x01\x1a\x1c\x20a\x20three-dimensional\x20object\x20\n\x0b\
    \n\x03\x04\x0c\x01\x12\x04\xaa\x02\x08\x13\nU\n\x04\x04\x0c\x02\0\x12\
    \x04\xad\x02\x08\"\x1aG\x20the\x20OSM\x20id\x20of\x20the\x20primary\x20e\
    lement\x20this\x20object\x20is\x20created\x20from,\x20if\x20any\x20\n\r\
    \n\x05\x04\x0c\x02\0\x04\x12\x04\xad\x02\x08\x10\n\r\n\x05\x04\x0c\x02\0\
    \x05\x12\x04\xad\x02\x11\x17\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\xad\x02\
    \x18\x1d\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\xad\x02\x20!\nU\n\x04\x04\
    \x0c\x02\x01\x12\x04\xb0\x02\x08%\x1aG\x20the\x20type\x20of\x20this\x20W\
    orldObject,\x20in\x20broad\x20terms.\x20References\x20stringBlock.\x20\n\
    \r\n\x05\x04\x0c\x02\x01\x04\x12\x04\xb0\x02\x08\x10\n\r\n\x05\x04\x0c\
    \x02\x01\x05\x12\x04\xb0\x02\x11\x17\n\r\n\x05\x04\x0c\x02\x01\x01\x12\
    \x04\xb0\x02\x18\x20\n\r\n\x05\x04\x0c\x02\x01\x03\x12\x04\xb0\x02#$\nv\
    \n\x04\x04\x0c\x02\x02\x12\x04\xb3\x02\x089\x1ah\x20geometry\x20this\x20\
    object\x20is\x20composed\x20of;\x20at\x20least\x201\x20of\x20this\x20or\
    \x20one\x20of\x20the\x20other\x20geometry\x20types\x20is\x20required\x20\
    \n\r\n\x05\x04\x0c\x02\x02\x04\x12\x04\xb3\x02\x08\x10\n\r\n\x05\x04\x0c\
    \x02\x02\x06\x12\x04\xb3\x02\x11!\n\r\n\x05\x04\x0c\x02\x02\x01\x12\x04\
    \xb3\x02\"4\n\r\n\x05\x04\x0c\x02\x02\x03\x12\x04\xb3\x0278\nv\n\x04\x04\
    \x0c\x02\x03\x12\x04\xb6\x02\x08;\x1ah\x20geometry\x20this\x20object\x20\
    is\x20composed\x20of;\x20at\x20least\x201\x20of\x20this\x20or\x20one\x20\
    of\x20the\x20other\x20geometry\x20types\x20is\x20required\x20\n\r\n\x05\
    \x04\x0c\x02\x03\x04\x12\x04\xb6\x02\x08\x10\n\r\n\x05\x04\x0c\x02\x03\
    \x06\x12\x04\xb6\x02\x11\"\n\r\n\x05\x04\x0c\x02\x03\x01\x12\x04\xb6\x02\
    #6\n\r\n\x05\x04\x0c\x02\x03\x03\x12\x04\xb6\x029:\nv\n\x04\x04\x0c\x02\
    \x04\x12\x04\xb9\x02\x089\x1ah\x20geometry\x20this\x20object\x20is\x20co\
    mposed\x20of;\x20at\x20least\x201\x20of\x20this\x20or\x20one\x20of\x20th\
    e\x20other\x20geometry\x20types\x20is\x20required\x20\n\r\n\x05\x04\x0c\
    \x02\x04\x04\x12\x04\xb9\x02\x08\x10\n\r\n\x05\x04\x0c\x02\x04\x06\x12\
    \x04\xb9\x02\x11!\n\r\n\x05\x04\x0c\x02\x04\x01\x12\x04\xb9\x02\"4\n\r\n\
    \x05\x04\x0c\x02\x04\x03\x12\x04\xb9\x0278\ng\n\x04\x04\x0c\x02\x05\x12\
    \x04\xbc\x02\x081\x1aY*\x20defines\x20a\x20level\x20of\x20detail\x20(0\
    \x20to\x204)\x20as\x20the\x20lower\x20end\x20of\x20the\x20range\x20where\
    \x20this\x20is\x20visible\x20\n\r\n\x05\x04\x0c\x02\x05\x04\x12\x04\xbc\
    \x02\x08\x10\n\r\n\x05\x04\x0c\x02\x05\x05\x12\x04\xbc\x02\x11\x17\n\r\n\
    \x05\x04\x0c\x02\x05\x01\x12\x04\xbc\x02\x18\x1e\n\r\n\x05\x04\x0c\x02\
    \x05\x03\x12\x04\xbc\x02!\"\n\r\n\x05\x04\x0c\x02\x05\x08\x12\x04\xbc\
    \x02#0\n\r\n\x05\x04\x0c\x02\x05\x07\x12\x04\xbc\x02./\ng\n\x04\x04\x0c\
    \x02\x06\x12\x04\xbf\x02\x081\x1aY*\x20defines\x20a\x20level\x20of\x20de\
    tail\x20(0\x20to\x204)\x20as\x20the\x20upper\x20end\x20of\x20the\x20rang\
    e\x20where\x20this\x20is\x20visible\x20\n\r\n\x05\x04\x0c\x02\x06\x04\
    \x12\x04\xbf\x02\x08\x10\n\r\n\x05\x04\x0c\x02\x06\x05\x12\x04\xbf\x02\
    \x11\x17\n\r\n\x05\x04\x0c\x02\x06\x01\x12\x04\xbf\x02\x18\x1e\n\r\n\x05\
    \x04\x0c\x02\x06\x03\x12\x04\xbf\x02!\"\n\r\n\x05\x04\x0c\x02\x06\x08\
    \x12\x04\xbf\x02#0\n\r\n\x05\x04\x0c\x02\x06\x07\x12\x04\xbf\x02./\n#\n\
    \x02\x04\r\x12\x06\xc4\x02\0\xcf\x02\x01\x1a\x15\x20a\x20tile\x20with\
    \x203d\x20data\x20\n\x0b\n\x03\x04\r\x01\x12\x04\xc4\x02\x08\x0c\n\x0c\n\
    \x04\x04\r\x02\0\x12\x04\xc6\x02\x081\n\r\n\x05\x04\r\x02\0\x04\x12\x04\
    \xc6\x02\x08\x10\n\r\n\x05\x04\r\x02\0\x06\x12\x04\xc6\x02\x11\x1e\n\r\n\
    \x05\x04\r\x02\0\x01\x12\x04\xc6\x02\x1f,\n\r\n\x05\x04\r\x02\0\x03\x12\
    \x04\xc6\x02/0\n\x0c\n\x04\x04\r\x02\x01\x12\x04\xc7\x02\x081\n\r\n\x05\
    \x04\r\x02\x01\x04\x12\x04\xc7\x02\x08\x10\n\r\n\x05\x04\r\x02\x01\x06\
    \x12\x04\xc7\x02\x11\x1e\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\xc7\x02\x1f\
    ,\n\r\n\x05\x04\r\x02\x01\x03\x12\x04\xc7\x02/0\n\x0c\n\x04\x04\r\x02\
    \x02\x12\x04\xc8\x02\x08-\n\r\n\x05\x04\r\x02\x02\x04\x12\x04\xc8\x02\
    \x08\x10\n\r\n\x05\x04\r\x02\x02\x06\x12\x04\xc8\x02\x11\x1c\n\r\n\x05\
    \x04\r\x02\x02\x01\x12\x04\xc8\x02\x1d(\n\r\n\x05\x04\r\x02\x02\x03\x12\
    \x04\xc8\x02+,\n\x0c\n\x04\x04\r\x02\x03\x12\x04\xc9\x02\x08+\n\r\n\x05\
    \x04\r\x02\x03\x04\x12\x04\xc9\x02\x08\x10\n\r\n\x05\x04\r\x02\x03\x06\
    \x12\x04\xc9\x02\x11\x1b\n\r\n\x05\x04\r\x02\x03\x01\x12\x04\xc9\x02\x1c\
    &\n\r\n\x05\x04\r\x02\x03\x03\x12\x04\xc9\x02)*\n\x0c\n\x04\x04\r\x02\
    \x04\x12\x04\xca\x02\x081\n\r\n\x05\x04\r\x02\x04\x04\x12\x04\xca\x02\
    \x08\x10\n\r\n\x05\x04\r\x02\x04\x06\x12\x04\xca\x02\x11\x1e\n\r\n\x05\
    \x04\r\x02\x04\x01\x12\x04\xca\x02\x1f,\n\r\n\x05\x04\r\x02\x04\x03\x12\
    \x04\xca\x02/0\n\x0c\n\x04\x04\r\x02\x05\x12\x04\xcb\x02\x08+\n\r\n\x05\
    \x04\r\x02\x05\x04\x12\x04\xcb\x02\x08\x10\n\r\n\x05\x04\r\x02\x05\x06\
    \x12\x04\xcb\x02\x11\x1b\n\r\n\x05\x04\r\x02\x05\x01\x12\x04\xcb\x02\x1c\
    &\n\r\n\x05\x04\r\x02\x05\x03\x12\x04\xcb\x02)*\n\x0c\n\x04\x04\r\x02\
    \x06\x12\x04\xcd\x02\x08)\n\r\n\x05\x04\r\x02\x06\x04\x12\x04\xcd\x02\
    \x08\x10\n\r\n\x05\x04\r\x02\x06\x06\x12\x04\xcd\x02\x11\x1c\n\r\n\x05\
    \x04\r\x02\x06\x01\x12\x04\xcd\x02\x1d$\n\r\n\x05\x04\r\x02\x06\x03\x12\
    \x04\xcd\x02'(\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(15);
            messages.push(Vector3dBlock::generated_message_descriptor_data());
            messages.push(Vector2dBlock::generated_message_descriptor_data());
            messages.push(StringBlock::generated_message_descriptor_data());
            messages.push(ShapeBlock::generated_message_descriptor_data());
            messages.push(Shape::generated_message_descriptor_data());
            messages.push(MaterialBlock::generated_message_descriptor_data());
            messages.push(Material::generated_message_descriptor_data());
            messages.push(ModelBlock::generated_message_descriptor_data());
            messages.push(TriangleGeometry::generated_message_descriptor_data());
            messages.push(ExtrusionGeometry::generated_message_descriptor_data());
            messages.push(InstanceGeometry::generated_message_descriptor_data());
            messages.push(Animation::generated_message_descriptor_data());
            messages.push(WorldObject::generated_message_descriptor_data());
            messages.push(Tile::generated_message_descriptor_data());
            messages.push(material::TextureLayer::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(7);
            enums.push(shape::ShapeType::generated_enum_descriptor_data());
            enums.push(material::Transparency::generated_enum_descriptor_data());
            enums.push(material::texture_layer::Wrap::generated_enum_descriptor_data());
            enums.push(material::texture_layer::TexCoordFunction::generated_enum_descriptor_data());
            enums.push(animation::AnimationType::generated_enum_descriptor_data());
            enums.push(animation::LoopMode::generated_enum_descriptor_data());
            enums.push(animation::TimerType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
