// This file is generated by rust-protobuf 2.24.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702

#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]

//???! Generated file from `frontend_v06.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_24_1;

#[derive(PartialEq,Clone,Default)]
pub struct Vector3dBlock {
    // message fields
    pub coords: ::std::vec::Vec<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Vector3dBlock {
    fn default() -> &'a Vector3dBlock {
        <Vector3dBlock as ::protobuf::Message>::default_instance()
    }
}

impl Vector3dBlock {
    pub fn new() -> Vector3dBlock {
        ::std::default::Default::default()
    }

    // repeated sint64 coords = 1;


    pub fn get_coords(&self) -> &[i64] {
        &self.coords
    }
    pub fn clear_coords(&mut self) {
        self.coords.clear();
    }

    // Param is passed by value, moved
    pub fn set_coords(&mut self, v: ::std::vec::Vec<i64>) {
        self.coords = v;
    }

    // Mutable pointer to the field.
    pub fn mut_coords(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.coords
    }

    // Take field
    pub fn take_coords(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.coords, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Vector3dBlock {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_sint64_into(wire_type, is, &mut self.coords)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.coords.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_zigzag_size(1, &self.coords);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.coords.is_empty() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_zigzag_data_size(&self.coords))?;
            for v in &self.coords {
                os.write_sint64_no_tag(*v)?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Vector3dBlock {
        Vector3dBlock::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                "coords",
                |m: &Vector3dBlock| { &m.coords },
                |m: &mut Vector3dBlock| { &mut m.coords },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Vector3dBlock>(
                "Vector3dBlock",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Vector3dBlock {
        static instance: ::protobuf::rt::LazyV2<Vector3dBlock> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Vector3dBlock::new)
    }
}

impl ::protobuf::Clear for Vector3dBlock {
    fn clear(&mut self) {
        self.coords.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Vector3dBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Vector3dBlock {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Vector2dBlock {
    // message fields
    pub coords: ::std::vec::Vec<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Vector2dBlock {
    fn default() -> &'a Vector2dBlock {
        <Vector2dBlock as ::protobuf::Message>::default_instance()
    }
}

impl Vector2dBlock {
    pub fn new() -> Vector2dBlock {
        ::std::default::Default::default()
    }

    // repeated sint64 coords = 1;


    pub fn get_coords(&self) -> &[i64] {
        &self.coords
    }
    pub fn clear_coords(&mut self) {
        self.coords.clear();
    }

    // Param is passed by value, moved
    pub fn set_coords(&mut self, v: ::std::vec::Vec<i64>) {
        self.coords = v;
    }

    // Mutable pointer to the field.
    pub fn mut_coords(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.coords
    }

    // Take field
    pub fn take_coords(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.coords, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Vector2dBlock {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_sint64_into(wire_type, is, &mut self.coords)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.coords.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_zigzag_size(1, &self.coords);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.coords.is_empty() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_zigzag_data_size(&self.coords))?;
            for v in &self.coords {
                os.write_sint64_no_tag(*v)?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Vector2dBlock {
        Vector2dBlock::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                "coords",
                |m: &Vector2dBlock| { &m.coords },
                |m: &mut Vector2dBlock| { &mut m.coords },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Vector2dBlock>(
                "Vector2dBlock",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Vector2dBlock {
        static instance: ::protobuf::rt::LazyV2<Vector2dBlock> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Vector2dBlock::new)
    }
}

impl ::protobuf::Clear for Vector2dBlock {
    fn clear(&mut self) {
        self.coords.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Vector2dBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Vector2dBlock {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StringBlock {
    // message fields
    pub strings: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StringBlock {
    fn default() -> &'a StringBlock {
        <StringBlock as ::protobuf::Message>::default_instance()
    }
}

impl StringBlock {
    pub fn new() -> StringBlock {
        ::std::default::Default::default()
    }

    // repeated string strings = 1;


    pub fn get_strings(&self) -> &[::std::string::String] {
        &self.strings
    }
    pub fn clear_strings(&mut self) {
        self.strings.clear();
    }

    // Param is passed by value, moved
    pub fn set_strings(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.strings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_strings(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.strings
    }

    // Take field
    pub fn take_strings(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.strings, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StringBlock {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.strings)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.strings {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.strings {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StringBlock {
        StringBlock::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "strings",
                |m: &StringBlock| { &m.strings },
                |m: &mut StringBlock| { &mut m.strings },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StringBlock>(
                "StringBlock",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StringBlock {
        static instance: ::protobuf::rt::LazyV2<StringBlock> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StringBlock::new)
    }
}

impl ::protobuf::Clear for StringBlock {
    fn clear(&mut self) {
        self.strings.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StringBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StringBlock {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ShapeBlock {
    // message fields
    pub shapes: ::protobuf::RepeatedField<Shape>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ShapeBlock {
    fn default() -> &'a ShapeBlock {
        <ShapeBlock as ::protobuf::Message>::default_instance()
    }
}

impl ShapeBlock {
    pub fn new() -> ShapeBlock {
        ::std::default::Default::default()
    }

    // repeated .frontend_pbf.Shape shapes = 1;


    pub fn get_shapes(&self) -> &[Shape] {
        &self.shapes
    }
    pub fn clear_shapes(&mut self) {
        self.shapes.clear();
    }

    // Param is passed by value, moved
    pub fn set_shapes(&mut self, v: ::protobuf::RepeatedField<Shape>) {
        self.shapes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_shapes(&mut self) -> &mut ::protobuf::RepeatedField<Shape> {
        &mut self.shapes
    }

    // Take field
    pub fn take_shapes(&mut self) -> ::protobuf::RepeatedField<Shape> {
        ::std::mem::replace(&mut self.shapes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ShapeBlock {
    fn is_initialized(&self) -> bool {
        for v in &self.shapes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.shapes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.shapes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.shapes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ShapeBlock {
        ShapeBlock::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Shape>>(
                "shapes",
                |m: &ShapeBlock| { &m.shapes },
                |m: &mut ShapeBlock| { &mut m.shapes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ShapeBlock>(
                "ShapeBlock",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ShapeBlock {
        static instance: ::protobuf::rt::LazyV2<ShapeBlock> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ShapeBlock::new)
    }
}

impl ::protobuf::Clear for ShapeBlock {
    fn clear(&mut self) {
        self.shapes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ShapeBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ShapeBlock {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Shape {
    // message fields
    field_type: ::std::option::Option<Shape_ShapeType>,
    pub parameters: ::std::vec::Vec<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Shape {
    fn default() -> &'a Shape {
        <Shape as ::protobuf::Message>::default_instance()
    }
}

impl Shape {
    pub fn new() -> Shape {
        ::std::default::Default::default()
    }

    // required .frontend_pbf.Shape.ShapeType type = 1;


    pub fn get_field_type(&self) -> Shape_ShapeType {
        self.field_type.unwrap_or(Shape_ShapeType::CIRCLE)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Shape_ShapeType) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // repeated sint64 parameters = 2;


    pub fn get_parameters(&self) -> &[i64] {
        &self.parameters
    }
    pub fn clear_parameters(&mut self) {
        self.parameters.clear();
    }

    // Param is passed by value, moved
    pub fn set_parameters(&mut self, v: ::std::vec::Vec<i64>) {
        self.parameters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_parameters(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.parameters
    }

    // Take field
    pub fn take_parameters(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.parameters, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Shape {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_repeated_sint64_into(wire_type, is, &mut self.parameters)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if !self.parameters.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_zigzag_size(2, &self.parameters);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if !self.parameters.is_empty() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_zigzag_data_size(&self.parameters))?;
            for v in &self.parameters {
                os.write_sint64_no_tag(*v)?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Shape {
        Shape::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Shape_ShapeType>>(
                "type",
                |m: &Shape| { &m.field_type },
                |m: &mut Shape| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                "parameters",
                |m: &Shape| { &m.parameters },
                |m: &mut Shape| { &mut m.parameters },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Shape>(
                "Shape",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Shape {
        static instance: ::protobuf::rt::LazyV2<Shape> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Shape::new)
    }
}

impl ::protobuf::Clear for Shape {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.parameters.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Shape {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Shape {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Shape_ShapeType {
    CIRCLE = 1,
    POLYGON = 2,
    POLYLINE = 3,
}

impl ::protobuf::ProtobufEnum for Shape_ShapeType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Shape_ShapeType> {
        match value {
            1 => ::std::option::Option::Some(Shape_ShapeType::CIRCLE),
            2 => ::std::option::Option::Some(Shape_ShapeType::POLYGON),
            3 => ::std::option::Option::Some(Shape_ShapeType::POLYLINE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Shape_ShapeType] = &[
            Shape_ShapeType::CIRCLE,
            Shape_ShapeType::POLYGON,
            Shape_ShapeType::POLYLINE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Shape_ShapeType>("Shape.ShapeType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Shape_ShapeType {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for Shape_ShapeType {
    fn default() -> Self {
        Shape_ShapeType::CIRCLE
    }
}

impl ::protobuf::reflect::ProtobufValue for Shape_ShapeType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MaterialBlock {
    // message fields
    pub materials: ::protobuf::RepeatedField<Material>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MaterialBlock {
    fn default() -> &'a MaterialBlock {
        <MaterialBlock as ::protobuf::Message>::default_instance()
    }
}

impl MaterialBlock {
    pub fn new() -> MaterialBlock {
        ::std::default::Default::default()
    }

    // repeated .frontend_pbf.Material materials = 1;


    pub fn get_materials(&self) -> &[Material] {
        &self.materials
    }
    pub fn clear_materials(&mut self) {
        self.materials.clear();
    }

    // Param is passed by value, moved
    pub fn set_materials(&mut self, v: ::protobuf::RepeatedField<Material>) {
        self.materials = v;
    }

    // Mutable pointer to the field.
    pub fn mut_materials(&mut self) -> &mut ::protobuf::RepeatedField<Material> {
        &mut self.materials
    }

    // Take field
    pub fn take_materials(&mut self) -> ::protobuf::RepeatedField<Material> {
        ::std::mem::replace(&mut self.materials, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MaterialBlock {
    fn is_initialized(&self) -> bool {
        for v in &self.materials {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.materials)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.materials {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.materials {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MaterialBlock {
        MaterialBlock::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Material>>(
                "materials",
                |m: &MaterialBlock| { &m.materials },
                |m: &mut MaterialBlock| { &mut m.materials },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MaterialBlock>(
                "MaterialBlock",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MaterialBlock {
        static instance: ::protobuf::rt::LazyV2<MaterialBlock> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MaterialBlock::new)
    }
}

impl ::protobuf::Clear for MaterialBlock {
    fn clear(&mut self) {
        self.materials.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MaterialBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MaterialBlock {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Material {
    // message fields
    baseColorR: ::std::option::Option<u32>,
    baseColorG: ::std::option::Option<u32>,
    baseColorB: ::std::option::Option<u32>,
    pub textureLayer: ::protobuf::RepeatedField<Material_TextureLayer>,
    transparency: ::std::option::Option<Material_Transparency>,
    castShadow: ::std::option::Option<bool>,
    doubleSided: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Material {
    fn default() -> &'a Material {
        <Material as ::protobuf::Message>::default_instance()
    }
}

impl Material {
    pub fn new() -> Material {
        ::std::default::Default::default()
    }

    // required uint32 baseColorR = 1;


    pub fn get_baseColorR(&self) -> u32 {
        self.baseColorR.unwrap_or(0)
    }
    pub fn clear_baseColorR(&mut self) {
        self.baseColorR = ::std::option::Option::None;
    }

    pub fn has_baseColorR(&self) -> bool {
        self.baseColorR.is_some()
    }

    // Param is passed by value, moved
    pub fn set_baseColorR(&mut self, v: u32) {
        self.baseColorR = ::std::option::Option::Some(v);
    }

    // required uint32 baseColorG = 2;


    pub fn get_baseColorG(&self) -> u32 {
        self.baseColorG.unwrap_or(0)
    }
    pub fn clear_baseColorG(&mut self) {
        self.baseColorG = ::std::option::Option::None;
    }

    pub fn has_baseColorG(&self) -> bool {
        self.baseColorG.is_some()
    }

    // Param is passed by value, moved
    pub fn set_baseColorG(&mut self, v: u32) {
        self.baseColorG = ::std::option::Option::Some(v);
    }

    // required uint32 baseColorB = 3;


    pub fn get_baseColorB(&self) -> u32 {
        self.baseColorB.unwrap_or(0)
    }
    pub fn clear_baseColorB(&mut self) {
        self.baseColorB = ::std::option::Option::None;
    }

    pub fn has_baseColorB(&self) -> bool {
        self.baseColorB.is_some()
    }

    // Param is passed by value, moved
    pub fn set_baseColorB(&mut self, v: u32) {
        self.baseColorB = ::std::option::Option::Some(v);
    }

    // repeated .frontend_pbf.Material.TextureLayer textureLayer = 11;


    pub fn get_textureLayer(&self) -> &[Material_TextureLayer] {
        &self.textureLayer
    }
    pub fn clear_textureLayer(&mut self) {
        self.textureLayer.clear();
    }

    // Param is passed by value, moved
    pub fn set_textureLayer(&mut self, v: ::protobuf::RepeatedField<Material_TextureLayer>) {
        self.textureLayer = v;
    }

    // Mutable pointer to the field.
    pub fn mut_textureLayer(&mut self) -> &mut ::protobuf::RepeatedField<Material_TextureLayer> {
        &mut self.textureLayer
    }

    // Take field
    pub fn take_textureLayer(&mut self) -> ::protobuf::RepeatedField<Material_TextureLayer> {
        ::std::mem::replace(&mut self.textureLayer, ::protobuf::RepeatedField::new())
    }

    // optional .frontend_pbf.Material.Transparency transparency = 16;


    pub fn get_transparency(&self) -> Material_Transparency {
        self.transparency.unwrap_or(Material_Transparency::FALSE)
    }
    pub fn clear_transparency(&mut self) {
        self.transparency = ::std::option::Option::None;
    }

    pub fn has_transparency(&self) -> bool {
        self.transparency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transparency(&mut self, v: Material_Transparency) {
        self.transparency = ::std::option::Option::Some(v);
    }

    // optional bool castShadow = 17;


    pub fn get_castShadow(&self) -> bool {
        self.castShadow.unwrap_or(true)
    }
    pub fn clear_castShadow(&mut self) {
        self.castShadow = ::std::option::Option::None;
    }

    pub fn has_castShadow(&self) -> bool {
        self.castShadow.is_some()
    }

    // Param is passed by value, moved
    pub fn set_castShadow(&mut self, v: bool) {
        self.castShadow = ::std::option::Option::Some(v);
    }

    // optional bool doubleSided = 18;


    pub fn get_doubleSided(&self) -> bool {
        self.doubleSided.unwrap_or(false)
    }
    pub fn clear_doubleSided(&mut self) {
        self.doubleSided = ::std::option::Option::None;
    }

    pub fn has_doubleSided(&self) -> bool {
        self.doubleSided.is_some()
    }

    // Param is passed by value, moved
    pub fn set_doubleSided(&mut self, v: bool) {
        self.doubleSided = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Material {
    fn is_initialized(&self) -> bool {
        if self.baseColorR.is_none() {
            return false;
        }
        if self.baseColorG.is_none() {
            return false;
        }
        if self.baseColorB.is_none() {
            return false;
        }
        for v in &self.textureLayer {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.baseColorR = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.baseColorG = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.baseColorB = ::std::option::Option::Some(tmp);
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.textureLayer)?;
                },
                16 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.transparency, 16, &mut self.unknown_fields)?
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.castShadow = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.doubleSided = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.baseColorR {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.baseColorG {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.baseColorB {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.textureLayer {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.transparency {
            my_size += ::protobuf::rt::enum_size(16, v);
        }
        if let Some(v) = self.castShadow {
            my_size += 3;
        }
        if let Some(v) = self.doubleSided {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.baseColorR {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.baseColorG {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.baseColorB {
            os.write_uint32(3, v)?;
        }
        for v in &self.textureLayer {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.transparency {
            os.write_enum(16, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.castShadow {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.doubleSided {
            os.write_bool(18, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Material {
        Material::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "baseColorR",
                |m: &Material| { &m.baseColorR },
                |m: &mut Material| { &mut m.baseColorR },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "baseColorG",
                |m: &Material| { &m.baseColorG },
                |m: &mut Material| { &mut m.baseColorG },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "baseColorB",
                |m: &Material| { &m.baseColorB },
                |m: &mut Material| { &mut m.baseColorB },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Material_TextureLayer>>(
                "textureLayer",
                |m: &Material| { &m.textureLayer },
                |m: &mut Material| { &mut m.textureLayer },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Material_Transparency>>(
                "transparency",
                |m: &Material| { &m.transparency },
                |m: &mut Material| { &mut m.transparency },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "castShadow",
                |m: &Material| { &m.castShadow },
                |m: &mut Material| { &mut m.castShadow },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "doubleSided",
                |m: &Material| { &m.doubleSided },
                |m: &mut Material| { &mut m.doubleSided },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Material>(
                "Material",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Material {
        static instance: ::protobuf::rt::LazyV2<Material> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Material::new)
    }
}

impl ::protobuf::Clear for Material {
    fn clear(&mut self) {
        self.baseColorR = ::std::option::Option::None;
        self.baseColorG = ::std::option::Option::None;
        self.baseColorB = ::std::option::Option::None;
        self.textureLayer.clear();
        self.transparency = ::std::option::Option::None;
        self.castShadow = ::std::option::Option::None;
        self.doubleSided = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Material {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Material {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Material_TextureLayer {
    // message fields
    baseColorTextureURI: ::protobuf::SingularField<::std::string::String>,
    ormTextureURI: ::protobuf::SingularField<::std::string::String>,
    normalTextureURI: ::protobuf::SingularField<::std::string::String>,
    displacementTextureURI: ::protobuf::SingularField<::std::string::String>,
    emissiveTextureURI: ::protobuf::SingularField<::std::string::String>,
    reflectivityTextureURI: ::protobuf::SingularField<::std::string::String>,
    wrap: ::std::option::Option<Material_TextureLayer_Wrap>,
    colorable: ::std::option::Option<bool>,
    textureWidth: ::std::option::Option<u32>,
    textureHeight: ::std::option::Option<u32>,
    texCoordFunction: ::std::option::Option<Material_TextureLayer_TexCoordFunction>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Material_TextureLayer {
    fn default() -> &'a Material_TextureLayer {
        <Material_TextureLayer as ::protobuf::Message>::default_instance()
    }
}

impl Material_TextureLayer {
    pub fn new() -> Material_TextureLayer {
        ::std::default::Default::default()
    }

    // optional string baseColorTextureURI = 1;


    pub fn get_baseColorTextureURI(&self) -> &str {
        match self.baseColorTextureURI.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_baseColorTextureURI(&mut self) {
        self.baseColorTextureURI.clear();
    }

    pub fn has_baseColorTextureURI(&self) -> bool {
        self.baseColorTextureURI.is_some()
    }

    // Param is passed by value, moved
    pub fn set_baseColorTextureURI(&mut self, v: ::std::string::String) {
        self.baseColorTextureURI = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_baseColorTextureURI(&mut self) -> &mut ::std::string::String {
        if self.baseColorTextureURI.is_none() {
            self.baseColorTextureURI.set_default();
        }
        self.baseColorTextureURI.as_mut().unwrap()
    }

    // Take field
    pub fn take_baseColorTextureURI(&mut self) -> ::std::string::String {
        self.baseColorTextureURI.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string ormTextureURI = 7;


    pub fn get_ormTextureURI(&self) -> &str {
        match self.ormTextureURI.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_ormTextureURI(&mut self) {
        self.ormTextureURI.clear();
    }

    pub fn has_ormTextureURI(&self) -> bool {
        self.ormTextureURI.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ormTextureURI(&mut self, v: ::std::string::String) {
        self.ormTextureURI = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ormTextureURI(&mut self) -> &mut ::std::string::String {
        if self.ormTextureURI.is_none() {
            self.ormTextureURI.set_default();
        }
        self.ormTextureURI.as_mut().unwrap()
    }

    // Take field
    pub fn take_ormTextureURI(&mut self) -> ::std::string::String {
        self.ormTextureURI.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string normalTextureURI = 8;


    pub fn get_normalTextureURI(&self) -> &str {
        match self.normalTextureURI.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_normalTextureURI(&mut self) {
        self.normalTextureURI.clear();
    }

    pub fn has_normalTextureURI(&self) -> bool {
        self.normalTextureURI.is_some()
    }

    // Param is passed by value, moved
    pub fn set_normalTextureURI(&mut self, v: ::std::string::String) {
        self.normalTextureURI = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_normalTextureURI(&mut self) -> &mut ::std::string::String {
        if self.normalTextureURI.is_none() {
            self.normalTextureURI.set_default();
        }
        self.normalTextureURI.as_mut().unwrap()
    }

    // Take field
    pub fn take_normalTextureURI(&mut self) -> ::std::string::String {
        self.normalTextureURI.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string displacementTextureURI = 9;


    pub fn get_displacementTextureURI(&self) -> &str {
        match self.displacementTextureURI.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_displacementTextureURI(&mut self) {
        self.displacementTextureURI.clear();
    }

    pub fn has_displacementTextureURI(&self) -> bool {
        self.displacementTextureURI.is_some()
    }

    // Param is passed by value, moved
    pub fn set_displacementTextureURI(&mut self, v: ::std::string::String) {
        self.displacementTextureURI = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_displacementTextureURI(&mut self) -> &mut ::std::string::String {
        if self.displacementTextureURI.is_none() {
            self.displacementTextureURI.set_default();
        }
        self.displacementTextureURI.as_mut().unwrap()
    }

    // Take field
    pub fn take_displacementTextureURI(&mut self) -> ::std::string::String {
        self.displacementTextureURI.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string emissiveTextureURI = 10;


    pub fn get_emissiveTextureURI(&self) -> &str {
        match self.emissiveTextureURI.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_emissiveTextureURI(&mut self) {
        self.emissiveTextureURI.clear();
    }

    pub fn has_emissiveTextureURI(&self) -> bool {
        self.emissiveTextureURI.is_some()
    }

    // Param is passed by value, moved
    pub fn set_emissiveTextureURI(&mut self, v: ::std::string::String) {
        self.emissiveTextureURI = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_emissiveTextureURI(&mut self) -> &mut ::std::string::String {
        if self.emissiveTextureURI.is_none() {
            self.emissiveTextureURI.set_default();
        }
        self.emissiveTextureURI.as_mut().unwrap()
    }

    // Take field
    pub fn take_emissiveTextureURI(&mut self) -> ::std::string::String {
        self.emissiveTextureURI.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string reflectivityTextureURI = 11;


    pub fn get_reflectivityTextureURI(&self) -> &str {
        match self.reflectivityTextureURI.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_reflectivityTextureURI(&mut self) {
        self.reflectivityTextureURI.clear();
    }

    pub fn has_reflectivityTextureURI(&self) -> bool {
        self.reflectivityTextureURI.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reflectivityTextureURI(&mut self, v: ::std::string::String) {
        self.reflectivityTextureURI = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reflectivityTextureURI(&mut self) -> &mut ::std::string::String {
        if self.reflectivityTextureURI.is_none() {
            self.reflectivityTextureURI.set_default();
        }
        self.reflectivityTextureURI.as_mut().unwrap()
    }

    // Take field
    pub fn take_reflectivityTextureURI(&mut self) -> ::std::string::String {
        self.reflectivityTextureURI.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .frontend_pbf.Material.TextureLayer.Wrap wrap = 2;


    pub fn get_wrap(&self) -> Material_TextureLayer_Wrap {
        self.wrap.unwrap_or(Material_TextureLayer_Wrap::REPEAT)
    }
    pub fn clear_wrap(&mut self) {
        self.wrap = ::std::option::Option::None;
    }

    pub fn has_wrap(&self) -> bool {
        self.wrap.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wrap(&mut self, v: Material_TextureLayer_Wrap) {
        self.wrap = ::std::option::Option::Some(v);
    }

    // required bool colorable = 3;


    pub fn get_colorable(&self) -> bool {
        self.colorable.unwrap_or(false)
    }
    pub fn clear_colorable(&mut self) {
        self.colorable = ::std::option::Option::None;
    }

    pub fn has_colorable(&self) -> bool {
        self.colorable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_colorable(&mut self, v: bool) {
        self.colorable = ::std::option::Option::Some(v);
    }

    // required uint32 textureWidth = 4;


    pub fn get_textureWidth(&self) -> u32 {
        self.textureWidth.unwrap_or(0)
    }
    pub fn clear_textureWidth(&mut self) {
        self.textureWidth = ::std::option::Option::None;
    }

    pub fn has_textureWidth(&self) -> bool {
        self.textureWidth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_textureWidth(&mut self, v: u32) {
        self.textureWidth = ::std::option::Option::Some(v);
    }

    // required uint32 textureHeight = 5;


    pub fn get_textureHeight(&self) -> u32 {
        self.textureHeight.unwrap_or(0)
    }
    pub fn clear_textureHeight(&mut self) {
        self.textureHeight = ::std::option::Option::None;
    }

    pub fn has_textureHeight(&self) -> bool {
        self.textureHeight.is_some()
    }

    // Param is passed by value, moved
    pub fn set_textureHeight(&mut self, v: u32) {
        self.textureHeight = ::std::option::Option::Some(v);
    }

    // optional .frontend_pbf.Material.TextureLayer.TexCoordFunction texCoordFunction = 6;


    pub fn get_texCoordFunction(&self) -> Material_TextureLayer_TexCoordFunction {
        self.texCoordFunction.unwrap_or(Material_TextureLayer_TexCoordFunction::CUSTOM)
    }
    pub fn clear_texCoordFunction(&mut self) {
        self.texCoordFunction = ::std::option::Option::None;
    }

    pub fn has_texCoordFunction(&self) -> bool {
        self.texCoordFunction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_texCoordFunction(&mut self, v: Material_TextureLayer_TexCoordFunction) {
        self.texCoordFunction = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Material_TextureLayer {
    fn is_initialized(&self) -> bool {
        if self.colorable.is_none() {
            return false;
        }
        if self.textureWidth.is_none() {
            return false;
        }
        if self.textureHeight.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.baseColorTextureURI)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ormTextureURI)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.normalTextureURI)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.displacementTextureURI)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.emissiveTextureURI)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reflectivityTextureURI)?;
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.wrap, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.colorable = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.textureWidth = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.textureHeight = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.texCoordFunction, 6, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.baseColorTextureURI.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.ormTextureURI.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.normalTextureURI.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.displacementTextureURI.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(ref v) = self.emissiveTextureURI.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(ref v) = self.reflectivityTextureURI.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.wrap {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(v) = self.colorable {
            my_size += 2;
        }
        if let Some(v) = self.textureWidth {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.textureHeight {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.texCoordFunction {
            my_size += ::protobuf::rt::enum_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.baseColorTextureURI.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.ormTextureURI.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.normalTextureURI.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.displacementTextureURI.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(ref v) = self.emissiveTextureURI.as_ref() {
            os.write_string(10, &v)?;
        }
        if let Some(ref v) = self.reflectivityTextureURI.as_ref() {
            os.write_string(11, &v)?;
        }
        if let Some(v) = self.wrap {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.colorable {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.textureWidth {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.textureHeight {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.texCoordFunction {
            os.write_enum(6, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Material_TextureLayer {
        Material_TextureLayer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "baseColorTextureURI",
                |m: &Material_TextureLayer| { &m.baseColorTextureURI },
                |m: &mut Material_TextureLayer| { &mut m.baseColorTextureURI },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ormTextureURI",
                |m: &Material_TextureLayer| { &m.ormTextureURI },
                |m: &mut Material_TextureLayer| { &mut m.ormTextureURI },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "normalTextureURI",
                |m: &Material_TextureLayer| { &m.normalTextureURI },
                |m: &mut Material_TextureLayer| { &mut m.normalTextureURI },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "displacementTextureURI",
                |m: &Material_TextureLayer| { &m.displacementTextureURI },
                |m: &mut Material_TextureLayer| { &mut m.displacementTextureURI },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "emissiveTextureURI",
                |m: &Material_TextureLayer| { &m.emissiveTextureURI },
                |m: &mut Material_TextureLayer| { &mut m.emissiveTextureURI },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "reflectivityTextureURI",
                |m: &Material_TextureLayer| { &m.reflectivityTextureURI },
                |m: &mut Material_TextureLayer| { &mut m.reflectivityTextureURI },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Material_TextureLayer_Wrap>>(
                "wrap",
                |m: &Material_TextureLayer| { &m.wrap },
                |m: &mut Material_TextureLayer| { &mut m.wrap },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "colorable",
                |m: &Material_TextureLayer| { &m.colorable },
                |m: &mut Material_TextureLayer| { &mut m.colorable },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "textureWidth",
                |m: &Material_TextureLayer| { &m.textureWidth },
                |m: &mut Material_TextureLayer| { &mut m.textureWidth },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "textureHeight",
                |m: &Material_TextureLayer| { &m.textureHeight },
                |m: &mut Material_TextureLayer| { &mut m.textureHeight },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Material_TextureLayer_TexCoordFunction>>(
                "texCoordFunction",
                |m: &Material_TextureLayer| { &m.texCoordFunction },
                |m: &mut Material_TextureLayer| { &mut m.texCoordFunction },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Material_TextureLayer>(
                "Material.TextureLayer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Material_TextureLayer {
        static instance: ::protobuf::rt::LazyV2<Material_TextureLayer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Material_TextureLayer::new)
    }
}

impl ::protobuf::Clear for Material_TextureLayer {
    fn clear(&mut self) {
        self.baseColorTextureURI.clear();
        self.ormTextureURI.clear();
        self.normalTextureURI.clear();
        self.displacementTextureURI.clear();
        self.emissiveTextureURI.clear();
        self.reflectivityTextureURI.clear();
        self.wrap = ::std::option::Option::None;
        self.colorable = ::std::option::Option::None;
        self.textureWidth = ::std::option::Option::None;
        self.textureHeight = ::std::option::Option::None;
        self.texCoordFunction = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Material_TextureLayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Material_TextureLayer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Material_TextureLayer_Wrap {
    REPEAT = 1,
    CLAMP = 2,
}

impl ::protobuf::ProtobufEnum for Material_TextureLayer_Wrap {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Material_TextureLayer_Wrap> {
        match value {
            1 => ::std::option::Option::Some(Material_TextureLayer_Wrap::REPEAT),
            2 => ::std::option::Option::Some(Material_TextureLayer_Wrap::CLAMP),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Material_TextureLayer_Wrap] = &[
            Material_TextureLayer_Wrap::REPEAT,
            Material_TextureLayer_Wrap::CLAMP,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Material_TextureLayer_Wrap>("Material.TextureLayer.Wrap", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Material_TextureLayer_Wrap {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for Material_TextureLayer_Wrap {
    fn default() -> Self {
        Material_TextureLayer_Wrap::REPEAT
    }
}

impl ::protobuf::reflect::ProtobufValue for Material_TextureLayer_Wrap {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Material_TextureLayer_TexCoordFunction {
    CUSTOM = 1,
    GLOBAL_X_Z = 2,
}

impl ::protobuf::ProtobufEnum for Material_TextureLayer_TexCoordFunction {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Material_TextureLayer_TexCoordFunction> {
        match value {
            1 => ::std::option::Option::Some(Material_TextureLayer_TexCoordFunction::CUSTOM),
            2 => ::std::option::Option::Some(Material_TextureLayer_TexCoordFunction::GLOBAL_X_Z),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Material_TextureLayer_TexCoordFunction] = &[
            Material_TextureLayer_TexCoordFunction::CUSTOM,
            Material_TextureLayer_TexCoordFunction::GLOBAL_X_Z,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Material_TextureLayer_TexCoordFunction>("Material.TextureLayer.TexCoordFunction", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Material_TextureLayer_TexCoordFunction {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for Material_TextureLayer_TexCoordFunction {
    fn default() -> Self {
        Material_TextureLayer_TexCoordFunction::CUSTOM
    }
}

impl ::protobuf::reflect::ProtobufValue for Material_TextureLayer_TexCoordFunction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Material_Transparency {
    TRUE = 1,
    BINARY = 2,
    FALSE = 3,
}

impl ::protobuf::ProtobufEnum for Material_Transparency {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Material_Transparency> {
        match value {
            1 => ::std::option::Option::Some(Material_Transparency::TRUE),
            2 => ::std::option::Option::Some(Material_Transparency::BINARY),
            3 => ::std::option::Option::Some(Material_Transparency::FALSE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Material_Transparency] = &[
            Material_Transparency::TRUE,
            Material_Transparency::BINARY,
            Material_Transparency::FALSE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Material_Transparency>("Material.Transparency", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Material_Transparency {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for Material_Transparency {
    fn default() -> Self {
        Material_Transparency::TRUE
    }
}

impl ::protobuf::reflect::ProtobufValue for Material_Transparency {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ModelBlock {
    // message fields
    pub models: ::protobuf::RepeatedField<WorldObject>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ModelBlock {
    fn default() -> &'a ModelBlock {
        <ModelBlock as ::protobuf::Message>::default_instance()
    }
}

impl ModelBlock {
    pub fn new() -> ModelBlock {
        ::std::default::Default::default()
    }

    // repeated .frontend_pbf.WorldObject models = 1;


    pub fn get_models(&self) -> &[WorldObject] {
        &self.models
    }
    pub fn clear_models(&mut self) {
        self.models.clear();
    }

    // Param is passed by value, moved
    pub fn set_models(&mut self, v: ::protobuf::RepeatedField<WorldObject>) {
        self.models = v;
    }

    // Mutable pointer to the field.
    pub fn mut_models(&mut self) -> &mut ::protobuf::RepeatedField<WorldObject> {
        &mut self.models
    }

    // Take field
    pub fn take_models(&mut self) -> ::protobuf::RepeatedField<WorldObject> {
        ::std::mem::replace(&mut self.models, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ModelBlock {
    fn is_initialized(&self) -> bool {
        for v in &self.models {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.models)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.models {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.models {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ModelBlock {
        ModelBlock::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WorldObject>>(
                "models",
                |m: &ModelBlock| { &m.models },
                |m: &mut ModelBlock| { &mut m.models },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ModelBlock>(
                "ModelBlock",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ModelBlock {
        static instance: ::protobuf::rt::LazyV2<ModelBlock> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ModelBlock::new)
    }
}

impl ::protobuf::Clear for ModelBlock {
    fn clear(&mut self) {
        self.models.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModelBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModelBlock {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TriangleGeometry {
    // message fields
    material: ::std::option::Option<u32>,
    pub vertices: ::std::vec::Vec<u64>,
    pub texCoords: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TriangleGeometry {
    fn default() -> &'a TriangleGeometry {
        <TriangleGeometry as ::protobuf::Message>::default_instance()
    }
}

impl TriangleGeometry {
    pub fn new() -> TriangleGeometry {
        ::std::default::Default::default()
    }

    // required uint32 material = 1;


    pub fn get_material(&self) -> u32 {
        self.material.unwrap_or(0)
    }
    pub fn clear_material(&mut self) {
        self.material = ::std::option::Option::None;
    }

    pub fn has_material(&self) -> bool {
        self.material.is_some()
    }

    // Param is passed by value, moved
    pub fn set_material(&mut self, v: u32) {
        self.material = ::std::option::Option::Some(v);
    }

    // repeated uint64 vertices = 2;


    pub fn get_vertices(&self) -> &[u64] {
        &self.vertices
    }
    pub fn clear_vertices(&mut self) {
        self.vertices.clear();
    }

    // Param is passed by value, moved
    pub fn set_vertices(&mut self, v: ::std::vec::Vec<u64>) {
        self.vertices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_vertices(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.vertices
    }

    // Take field
    pub fn take_vertices(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.vertices, ::std::vec::Vec::new())
    }

    // repeated uint64 texCoords = 3;


    pub fn get_texCoords(&self) -> &[u64] {
        &self.texCoords
    }
    pub fn clear_texCoords(&mut self) {
        self.texCoords.clear();
    }

    // Param is passed by value, moved
    pub fn set_texCoords(&mut self, v: ::std::vec::Vec<u64>) {
        self.texCoords = v;
    }

    // Mutable pointer to the field.
    pub fn mut_texCoords(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.texCoords
    }

    // Take field
    pub fn take_texCoords(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.texCoords, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for TriangleGeometry {
    fn is_initialized(&self) -> bool {
        if self.material.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.material = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.vertices)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.texCoords)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.material {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.vertices.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(2, &self.vertices);
        }
        if !self.texCoords.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(3, &self.texCoords);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.material {
            os.write_uint32(1, v)?;
        }
        if !self.vertices.is_empty() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.vertices))?;
            for v in &self.vertices {
                os.write_uint64_no_tag(*v)?;
            };
        }
        if !self.texCoords.is_empty() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.texCoords))?;
            for v in &self.texCoords {
                os.write_uint64_no_tag(*v)?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TriangleGeometry {
        TriangleGeometry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "material",
                |m: &TriangleGeometry| { &m.material },
                |m: &mut TriangleGeometry| { &mut m.material },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "vertices",
                |m: &TriangleGeometry| { &m.vertices },
                |m: &mut TriangleGeometry| { &mut m.vertices },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "texCoords",
                |m: &TriangleGeometry| { &m.texCoords },
                |m: &mut TriangleGeometry| { &mut m.texCoords },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TriangleGeometry>(
                "TriangleGeometry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TriangleGeometry {
        static instance: ::protobuf::rt::LazyV2<TriangleGeometry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TriangleGeometry::new)
    }
}

impl ::protobuf::Clear for TriangleGeometry {
    fn clear(&mut self) {
        self.material = ::std::option::Option::None;
        self.vertices.clear();
        self.texCoords.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TriangleGeometry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TriangleGeometry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExtrusionGeometry {
    // message fields
    material: ::std::option::Option<u32>,
    shape: ::std::option::Option<u32>,
    pub path: ::std::vec::Vec<u64>,
    pub upVectors: ::std::vec::Vec<u64>,
    pub scaleFactors: ::std::vec::Vec<u64>,
    startCap: ::std::option::Option<bool>,
    endCap: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExtrusionGeometry {
    fn default() -> &'a ExtrusionGeometry {
        <ExtrusionGeometry as ::protobuf::Message>::default_instance()
    }
}

impl ExtrusionGeometry {
    pub fn new() -> ExtrusionGeometry {
        ::std::default::Default::default()
    }

    // required uint32 material = 1;


    pub fn get_material(&self) -> u32 {
        self.material.unwrap_or(0)
    }
    pub fn clear_material(&mut self) {
        self.material = ::std::option::Option::None;
    }

    pub fn has_material(&self) -> bool {
        self.material.is_some()
    }

    // Param is passed by value, moved
    pub fn set_material(&mut self, v: u32) {
        self.material = ::std::option::Option::Some(v);
    }

    // required uint32 shape = 2;


    pub fn get_shape(&self) -> u32 {
        self.shape.unwrap_or(0)
    }
    pub fn clear_shape(&mut self) {
        self.shape = ::std::option::Option::None;
    }

    pub fn has_shape(&self) -> bool {
        self.shape.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shape(&mut self, v: u32) {
        self.shape = ::std::option::Option::Some(v);
    }

    // repeated uint64 path = 3;


    pub fn get_path(&self) -> &[u64] {
        &self.path
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::vec::Vec<u64>) {
        self.path = v;
    }

    // Mutable pointer to the field.
    pub fn mut_path(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.path, ::std::vec::Vec::new())
    }

    // repeated uint64 upVectors = 4;


    pub fn get_upVectors(&self) -> &[u64] {
        &self.upVectors
    }
    pub fn clear_upVectors(&mut self) {
        self.upVectors.clear();
    }

    // Param is passed by value, moved
    pub fn set_upVectors(&mut self, v: ::std::vec::Vec<u64>) {
        self.upVectors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_upVectors(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.upVectors
    }

    // Take field
    pub fn take_upVectors(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.upVectors, ::std::vec::Vec::new())
    }

    // repeated uint64 scaleFactors = 5;


    pub fn get_scaleFactors(&self) -> &[u64] {
        &self.scaleFactors
    }
    pub fn clear_scaleFactors(&mut self) {
        self.scaleFactors.clear();
    }

    // Param is passed by value, moved
    pub fn set_scaleFactors(&mut self, v: ::std::vec::Vec<u64>) {
        self.scaleFactors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_scaleFactors(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.scaleFactors
    }

    // Take field
    pub fn take_scaleFactors(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.scaleFactors, ::std::vec::Vec::new())
    }

    // optional bool startCap = 7;


    pub fn get_startCap(&self) -> bool {
        self.startCap.unwrap_or(false)
    }
    pub fn clear_startCap(&mut self) {
        self.startCap = ::std::option::Option::None;
    }

    pub fn has_startCap(&self) -> bool {
        self.startCap.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startCap(&mut self, v: bool) {
        self.startCap = ::std::option::Option::Some(v);
    }

    // optional bool endCap = 8;


    pub fn get_endCap(&self) -> bool {
        self.endCap.unwrap_or(false)
    }
    pub fn clear_endCap(&mut self) {
        self.endCap = ::std::option::Option::None;
    }

    pub fn has_endCap(&self) -> bool {
        self.endCap.is_some()
    }

    // Param is passed by value, moved
    pub fn set_endCap(&mut self, v: bool) {
        self.endCap = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ExtrusionGeometry {
    fn is_initialized(&self) -> bool {
        if self.material.is_none() {
            return false;
        }
        if self.shape.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.material = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.shape = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.path)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.upVectors)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.scaleFactors)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.startCap = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.endCap = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.material {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.shape {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.path {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.upVectors {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.scaleFactors {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.startCap {
            my_size += 2;
        }
        if let Some(v) = self.endCap {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.material {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.shape {
            os.write_uint32(2, v)?;
        }
        for v in &self.path {
            os.write_uint64(3, *v)?;
        };
        for v in &self.upVectors {
            os.write_uint64(4, *v)?;
        };
        for v in &self.scaleFactors {
            os.write_uint64(5, *v)?;
        };
        if let Some(v) = self.startCap {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.endCap {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExtrusionGeometry {
        ExtrusionGeometry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "material",
                |m: &ExtrusionGeometry| { &m.material },
                |m: &mut ExtrusionGeometry| { &mut m.material },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "shape",
                |m: &ExtrusionGeometry| { &m.shape },
                |m: &mut ExtrusionGeometry| { &mut m.shape },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "path",
                |m: &ExtrusionGeometry| { &m.path },
                |m: &mut ExtrusionGeometry| { &mut m.path },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "upVectors",
                |m: &ExtrusionGeometry| { &m.upVectors },
                |m: &mut ExtrusionGeometry| { &mut m.upVectors },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "scaleFactors",
                |m: &ExtrusionGeometry| { &m.scaleFactors },
                |m: &mut ExtrusionGeometry| { &mut m.scaleFactors },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "startCap",
                |m: &ExtrusionGeometry| { &m.startCap },
                |m: &mut ExtrusionGeometry| { &mut m.startCap },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "endCap",
                |m: &ExtrusionGeometry| { &m.endCap },
                |m: &mut ExtrusionGeometry| { &mut m.endCap },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExtrusionGeometry>(
                "ExtrusionGeometry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExtrusionGeometry {
        static instance: ::protobuf::rt::LazyV2<ExtrusionGeometry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExtrusionGeometry::new)
    }
}

impl ::protobuf::Clear for ExtrusionGeometry {
    fn clear(&mut self) {
        self.material = ::std::option::Option::None;
        self.shape = ::std::option::Option::None;
        self.path.clear();
        self.upVectors.clear();
        self.scaleFactors.clear();
        self.startCap = ::std::option::Option::None;
        self.endCap = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExtrusionGeometry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExtrusionGeometry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InstanceGeometry {
    // message fields
    model: ::std::option::Option<u32>,
    resourceIdentifier: ::protobuf::SingularField<::std::string::String>,
    pub position: ::std::vec::Vec<i64>,
    pub direction: ::std::vec::Vec<i32>,
    pub scale: ::std::vec::Vec<u32>,
    pub animation: ::protobuf::SingularPtrField<Animation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InstanceGeometry {
    fn default() -> &'a InstanceGeometry {
        <InstanceGeometry as ::protobuf::Message>::default_instance()
    }
}

impl InstanceGeometry {
    pub fn new() -> InstanceGeometry {
        ::std::default::Default::default()
    }

    // optional uint32 model = 1;


    pub fn get_model(&self) -> u32 {
        self.model.unwrap_or(0)
    }
    pub fn clear_model(&mut self) {
        self.model = ::std::option::Option::None;
    }

    pub fn has_model(&self) -> bool {
        self.model.is_some()
    }

    // Param is passed by value, moved
    pub fn set_model(&mut self, v: u32) {
        self.model = ::std::option::Option::Some(v);
    }

    // optional string resourceIdentifier = 5;


    pub fn get_resourceIdentifier(&self) -> &str {
        match self.resourceIdentifier.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_resourceIdentifier(&mut self) {
        self.resourceIdentifier.clear();
    }

    pub fn has_resourceIdentifier(&self) -> bool {
        self.resourceIdentifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceIdentifier(&mut self, v: ::std::string::String) {
        self.resourceIdentifier = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resourceIdentifier(&mut self) -> &mut ::std::string::String {
        if self.resourceIdentifier.is_none() {
            self.resourceIdentifier.set_default();
        }
        self.resourceIdentifier.as_mut().unwrap()
    }

    // Take field
    pub fn take_resourceIdentifier(&mut self) -> ::std::string::String {
        self.resourceIdentifier.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated sint64 position = 2;


    pub fn get_position(&self) -> &[i64] {
        &self.position
    }
    pub fn clear_position(&mut self) {
        self.position.clear();
    }

    // Param is passed by value, moved
    pub fn set_position(&mut self, v: ::std::vec::Vec<i64>) {
        self.position = v;
    }

    // Mutable pointer to the field.
    pub fn mut_position(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.position
    }

    // Take field
    pub fn take_position(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.position, ::std::vec::Vec::new())
    }

    // repeated int32 direction = 3;


    pub fn get_direction(&self) -> &[i32] {
        &self.direction
    }
    pub fn clear_direction(&mut self) {
        self.direction.clear();
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: ::std::vec::Vec<i32>) {
        self.direction = v;
    }

    // Mutable pointer to the field.
    pub fn mut_direction(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.direction
    }

    // Take field
    pub fn take_direction(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.direction, ::std::vec::Vec::new())
    }

    // repeated uint32 scale = 4;


    pub fn get_scale(&self) -> &[u32] {
        &self.scale
    }
    pub fn clear_scale(&mut self) {
        self.scale.clear();
    }

    // Param is passed by value, moved
    pub fn set_scale(&mut self, v: ::std::vec::Vec<u32>) {
        self.scale = v;
    }

    // Mutable pointer to the field.
    pub fn mut_scale(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.scale
    }

    // Take field
    pub fn take_scale(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.scale, ::std::vec::Vec::new())
    }

    // optional .frontend_pbf.Animation animation = 6;


    pub fn get_animation(&self) -> &Animation {
        self.animation.as_ref().unwrap_or_else(|| <Animation as ::protobuf::Message>::default_instance())
    }
    pub fn clear_animation(&mut self) {
        self.animation.clear();
    }

    pub fn has_animation(&self) -> bool {
        self.animation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_animation(&mut self, v: Animation) {
        self.animation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_animation(&mut self) -> &mut Animation {
        if self.animation.is_none() {
            self.animation.set_default();
        }
        self.animation.as_mut().unwrap()
    }

    // Take field
    pub fn take_animation(&mut self) -> Animation {
        self.animation.take().unwrap_or_else(|| Animation::new())
    }
}

impl ::protobuf::Message for InstanceGeometry {
    fn is_initialized(&self) -> bool {
        for v in &self.animation {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.model = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.resourceIdentifier)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_sint64_into(wire_type, is, &mut self.position)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.direction)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.scale)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.animation)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.model {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.resourceIdentifier.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if !self.position.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_zigzag_size(2, &self.position);
        }
        if !self.direction.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(3, &self.direction);
        }
        if !self.scale.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(4, &self.scale);
        }
        if let Some(ref v) = self.animation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.model {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.resourceIdentifier.as_ref() {
            os.write_string(5, &v)?;
        }
        if !self.position.is_empty() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_zigzag_data_size(&self.position))?;
            for v in &self.position {
                os.write_sint64_no_tag(*v)?;
            };
        }
        if !self.direction.is_empty() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.direction))?;
            for v in &self.direction {
                os.write_int32_no_tag(*v)?;
            };
        }
        if !self.scale.is_empty() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.scale))?;
            for v in &self.scale {
                os.write_uint32_no_tag(*v)?;
            };
        }
        if let Some(ref v) = self.animation.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InstanceGeometry {
        InstanceGeometry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "model",
                |m: &InstanceGeometry| { &m.model },
                |m: &mut InstanceGeometry| { &mut m.model },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "resourceIdentifier",
                |m: &InstanceGeometry| { &m.resourceIdentifier },
                |m: &mut InstanceGeometry| { &mut m.resourceIdentifier },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                "position",
                |m: &InstanceGeometry| { &m.position },
                |m: &mut InstanceGeometry| { &mut m.position },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "direction",
                |m: &InstanceGeometry| { &m.direction },
                |m: &mut InstanceGeometry| { &mut m.direction },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "scale",
                |m: &InstanceGeometry| { &m.scale },
                |m: &mut InstanceGeometry| { &mut m.scale },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Animation>>(
                "animation",
                |m: &InstanceGeometry| { &m.animation },
                |m: &mut InstanceGeometry| { &mut m.animation },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InstanceGeometry>(
                "InstanceGeometry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InstanceGeometry {
        static instance: ::protobuf::rt::LazyV2<InstanceGeometry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InstanceGeometry::new)
    }
}

impl ::protobuf::Clear for InstanceGeometry {
    fn clear(&mut self) {
        self.model = ::std::option::Option::None;
        self.resourceIdentifier.clear();
        self.position.clear();
        self.direction.clear();
        self.scale.clear();
        self.animation.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InstanceGeometry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InstanceGeometry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Animation {
    // message fields
    field_type: ::std::option::Option<Animation_AnimationType>,
    loopMode: ::std::option::Option<Animation_LoopMode>,
    timerType: ::std::option::Option<Animation_TimerType>,
    runsPerSecond: ::std::option::Option<f64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Animation {
    fn default() -> &'a Animation {
        <Animation as ::protobuf::Message>::default_instance()
    }
}

impl Animation {
    pub fn new() -> Animation {
        ::std::default::Default::default()
    }

    // required .frontend_pbf.Animation.AnimationType type = 1;


    pub fn get_field_type(&self) -> Animation_AnimationType {
        self.field_type.unwrap_or(Animation_AnimationType::ROTATION_X)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Animation_AnimationType) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional .frontend_pbf.Animation.LoopMode loopMode = 2;


    pub fn get_loopMode(&self) -> Animation_LoopMode {
        self.loopMode.unwrap_or(Animation_LoopMode::CYCLE)
    }
    pub fn clear_loopMode(&mut self) {
        self.loopMode = ::std::option::Option::None;
    }

    pub fn has_loopMode(&self) -> bool {
        self.loopMode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loopMode(&mut self, v: Animation_LoopMode) {
        self.loopMode = ::std::option::Option::Some(v);
    }

    // optional .frontend_pbf.Animation.TimerType timerType = 3;


    pub fn get_timerType(&self) -> Animation_TimerType {
        self.timerType.unwrap_or(Animation_TimerType::MODEL_TIME)
    }
    pub fn clear_timerType(&mut self) {
        self.timerType = ::std::option::Option::None;
    }

    pub fn has_timerType(&self) -> bool {
        self.timerType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timerType(&mut self, v: Animation_TimerType) {
        self.timerType = ::std::option::Option::Some(v);
    }

    // required double runsPerSecond = 4;


    pub fn get_runsPerSecond(&self) -> f64 {
        self.runsPerSecond.unwrap_or(0.)
    }
    pub fn clear_runsPerSecond(&mut self) {
        self.runsPerSecond = ::std::option::Option::None;
    }

    pub fn has_runsPerSecond(&self) -> bool {
        self.runsPerSecond.is_some()
    }

    // Param is passed by value, moved
    pub fn set_runsPerSecond(&mut self, v: f64) {
        self.runsPerSecond = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Animation {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        }
        if self.runsPerSecond.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.loopMode, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.timerType, 3, &mut self.unknown_fields)?
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.runsPerSecond = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.loopMode {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(v) = self.timerType {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        if let Some(v) = self.runsPerSecond {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.loopMode {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.timerType {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.runsPerSecond {
            os.write_double(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Animation {
        Animation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Animation_AnimationType>>(
                "type",
                |m: &Animation| { &m.field_type },
                |m: &mut Animation| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Animation_LoopMode>>(
                "loopMode",
                |m: &Animation| { &m.loopMode },
                |m: &mut Animation| { &mut m.loopMode },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Animation_TimerType>>(
                "timerType",
                |m: &Animation| { &m.timerType },
                |m: &mut Animation| { &mut m.timerType },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "runsPerSecond",
                |m: &Animation| { &m.runsPerSecond },
                |m: &mut Animation| { &mut m.runsPerSecond },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Animation>(
                "Animation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Animation {
        static instance: ::protobuf::rt::LazyV2<Animation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Animation::new)
    }
}

impl ::protobuf::Clear for Animation {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.loopMode = ::std::option::Option::None;
        self.timerType = ::std::option::Option::None;
        self.runsPerSecond = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Animation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Animation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Animation_AnimationType {
    ROTATION_X = 1,
}

impl ::protobuf::ProtobufEnum for Animation_AnimationType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Animation_AnimationType> {
        match value {
            1 => ::std::option::Option::Some(Animation_AnimationType::ROTATION_X),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Animation_AnimationType] = &[
            Animation_AnimationType::ROTATION_X,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Animation_AnimationType>("Animation.AnimationType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Animation_AnimationType {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for Animation_AnimationType {
    fn default() -> Self {
        Animation_AnimationType::ROTATION_X
    }
}

impl ::protobuf::reflect::ProtobufValue for Animation_AnimationType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Animation_LoopMode {
    CYCLE = 1,
}

impl ::protobuf::ProtobufEnum for Animation_LoopMode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Animation_LoopMode> {
        match value {
            1 => ::std::option::Option::Some(Animation_LoopMode::CYCLE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Animation_LoopMode] = &[
            Animation_LoopMode::CYCLE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Animation_LoopMode>("Animation.LoopMode", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Animation_LoopMode {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for Animation_LoopMode {
    fn default() -> Self {
        Animation_LoopMode::CYCLE
    }
}

impl ::protobuf::reflect::ProtobufValue for Animation_LoopMode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Animation_TimerType {
    MODEL_TIME = 1,
}

impl ::protobuf::ProtobufEnum for Animation_TimerType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Animation_TimerType> {
        match value {
            1 => ::std::option::Option::Some(Animation_TimerType::MODEL_TIME),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Animation_TimerType] = &[
            Animation_TimerType::MODEL_TIME,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Animation_TimerType>("Animation.TimerType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Animation_TimerType {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for Animation_TimerType {
    fn default() -> Self {
        Animation_TimerType::MODEL_TIME
    }
}

impl ::protobuf::reflect::ProtobufValue for Animation_TimerType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WorldObject {
    // message fields
    osmId: ::protobuf::SingularField<::std::string::String>,
    typeName: ::std::option::Option<u32>,
    pub triangleGeometries: ::protobuf::RepeatedField<TriangleGeometry>,
    pub extrusionGeometries: ::protobuf::RepeatedField<ExtrusionGeometry>,
    pub instanceGeometries: ::protobuf::RepeatedField<InstanceGeometry>,
    minLod: ::std::option::Option<u32>,
    maxLod: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WorldObject {
    fn default() -> &'a WorldObject {
        <WorldObject as ::protobuf::Message>::default_instance()
    }
}

impl WorldObject {
    pub fn new() -> WorldObject {
        ::std::default::Default::default()
    }

    // optional string osmId = 1;


    pub fn get_osmId(&self) -> &str {
        match self.osmId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_osmId(&mut self) {
        self.osmId.clear();
    }

    pub fn has_osmId(&self) -> bool {
        self.osmId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_osmId(&mut self, v: ::std::string::String) {
        self.osmId = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_osmId(&mut self) -> &mut ::std::string::String {
        if self.osmId.is_none() {
            self.osmId.set_default();
        }
        self.osmId.as_mut().unwrap()
    }

    // Take field
    pub fn take_osmId(&mut self) -> ::std::string::String {
        self.osmId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 typeName = 2;


    pub fn get_typeName(&self) -> u32 {
        self.typeName.unwrap_or(0)
    }
    pub fn clear_typeName(&mut self) {
        self.typeName = ::std::option::Option::None;
    }

    pub fn has_typeName(&self) -> bool {
        self.typeName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_typeName(&mut self, v: u32) {
        self.typeName = ::std::option::Option::Some(v);
    }

    // repeated .frontend_pbf.TriangleGeometry triangleGeometries = 3;


    pub fn get_triangleGeometries(&self) -> &[TriangleGeometry] {
        &self.triangleGeometries
    }
    pub fn clear_triangleGeometries(&mut self) {
        self.triangleGeometries.clear();
    }

    // Param is passed by value, moved
    pub fn set_triangleGeometries(&mut self, v: ::protobuf::RepeatedField<TriangleGeometry>) {
        self.triangleGeometries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_triangleGeometries(&mut self) -> &mut ::protobuf::RepeatedField<TriangleGeometry> {
        &mut self.triangleGeometries
    }

    // Take field
    pub fn take_triangleGeometries(&mut self) -> ::protobuf::RepeatedField<TriangleGeometry> {
        ::std::mem::replace(&mut self.triangleGeometries, ::protobuf::RepeatedField::new())
    }

    // repeated .frontend_pbf.ExtrusionGeometry extrusionGeometries = 4;


    pub fn get_extrusionGeometries(&self) -> &[ExtrusionGeometry] {
        &self.extrusionGeometries
    }
    pub fn clear_extrusionGeometries(&mut self) {
        self.extrusionGeometries.clear();
    }

    // Param is passed by value, moved
    pub fn set_extrusionGeometries(&mut self, v: ::protobuf::RepeatedField<ExtrusionGeometry>) {
        self.extrusionGeometries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extrusionGeometries(&mut self) -> &mut ::protobuf::RepeatedField<ExtrusionGeometry> {
        &mut self.extrusionGeometries
    }

    // Take field
    pub fn take_extrusionGeometries(&mut self) -> ::protobuf::RepeatedField<ExtrusionGeometry> {
        ::std::mem::replace(&mut self.extrusionGeometries, ::protobuf::RepeatedField::new())
    }

    // repeated .frontend_pbf.InstanceGeometry instanceGeometries = 5;


    pub fn get_instanceGeometries(&self) -> &[InstanceGeometry] {
        &self.instanceGeometries
    }
    pub fn clear_instanceGeometries(&mut self) {
        self.instanceGeometries.clear();
    }

    // Param is passed by value, moved
    pub fn set_instanceGeometries(&mut self, v: ::protobuf::RepeatedField<InstanceGeometry>) {
        self.instanceGeometries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_instanceGeometries(&mut self) -> &mut ::protobuf::RepeatedField<InstanceGeometry> {
        &mut self.instanceGeometries
    }

    // Take field
    pub fn take_instanceGeometries(&mut self) -> ::protobuf::RepeatedField<InstanceGeometry> {
        ::std::mem::replace(&mut self.instanceGeometries, ::protobuf::RepeatedField::new())
    }

    // optional uint32 minLod = 6;


    pub fn get_minLod(&self) -> u32 {
        self.minLod.unwrap_or(0u32)
    }
    pub fn clear_minLod(&mut self) {
        self.minLod = ::std::option::Option::None;
    }

    pub fn has_minLod(&self) -> bool {
        self.minLod.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minLod(&mut self, v: u32) {
        self.minLod = ::std::option::Option::Some(v);
    }

    // optional uint32 maxLod = 7;


    pub fn get_maxLod(&self) -> u32 {
        self.maxLod.unwrap_or(4u32)
    }
    pub fn clear_maxLod(&mut self) {
        self.maxLod = ::std::option::Option::None;
    }

    pub fn has_maxLod(&self) -> bool {
        self.maxLod.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxLod(&mut self, v: u32) {
        self.maxLod = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for WorldObject {
    fn is_initialized(&self) -> bool {
        for v in &self.triangleGeometries {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extrusionGeometries {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.instanceGeometries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.osmId)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.typeName = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.triangleGeometries)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extrusionGeometries)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.instanceGeometries)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.minLod = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.maxLod = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.osmId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.typeName {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.triangleGeometries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.extrusionGeometries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.instanceGeometries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.minLod {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.maxLod {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.osmId.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.typeName {
            os.write_uint32(2, v)?;
        }
        for v in &self.triangleGeometries {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.extrusionGeometries {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.instanceGeometries {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.minLod {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.maxLod {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WorldObject {
        WorldObject::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "osmId",
                |m: &WorldObject| { &m.osmId },
                |m: &mut WorldObject| { &mut m.osmId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "typeName",
                |m: &WorldObject| { &m.typeName },
                |m: &mut WorldObject| { &mut m.typeName },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TriangleGeometry>>(
                "triangleGeometries",
                |m: &WorldObject| { &m.triangleGeometries },
                |m: &mut WorldObject| { &mut m.triangleGeometries },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExtrusionGeometry>>(
                "extrusionGeometries",
                |m: &WorldObject| { &m.extrusionGeometries },
                |m: &mut WorldObject| { &mut m.extrusionGeometries },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InstanceGeometry>>(
                "instanceGeometries",
                |m: &WorldObject| { &m.instanceGeometries },
                |m: &mut WorldObject| { &mut m.instanceGeometries },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "minLod",
                |m: &WorldObject| { &m.minLod },
                |m: &mut WorldObject| { &mut m.minLod },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "maxLod",
                |m: &WorldObject| { &m.maxLod },
                |m: &mut WorldObject| { &mut m.maxLod },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WorldObject>(
                "WorldObject",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WorldObject {
        static instance: ::protobuf::rt::LazyV2<WorldObject> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WorldObject::new)
    }
}

impl ::protobuf::Clear for WorldObject {
    fn clear(&mut self) {
        self.osmId.clear();
        self.typeName = ::std::option::Option::None;
        self.triangleGeometries.clear();
        self.extrusionGeometries.clear();
        self.instanceGeometries.clear();
        self.minLod = ::std::option::Option::None;
        self.maxLod = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WorldObject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WorldObject {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Tile {
    // message fields
    pub vector3dBlock: ::protobuf::SingularPtrField<Vector3dBlock>,
    pub vector2dBlock: ::protobuf::SingularPtrField<Vector2dBlock>,
    pub stringBlock: ::protobuf::SingularPtrField<StringBlock>,
    pub shapeBlock: ::protobuf::SingularPtrField<ShapeBlock>,
    pub materialBlock: ::protobuf::SingularPtrField<MaterialBlock>,
    pub modelBlock: ::protobuf::SingularPtrField<ModelBlock>,
    pub objects: ::protobuf::RepeatedField<WorldObject>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Tile {
    fn default() -> &'a Tile {
        <Tile as ::protobuf::Message>::default_instance()
    }
}

impl Tile {
    pub fn new() -> Tile {
        ::std::default::Default::default()
    }

    // required .frontend_pbf.Vector3dBlock vector3dBlock = 1;


    pub fn get_vector3dBlock(&self) -> &Vector3dBlock {
        self.vector3dBlock.as_ref().unwrap_or_else(|| <Vector3dBlock as ::protobuf::Message>::default_instance())
    }
    pub fn clear_vector3dBlock(&mut self) {
        self.vector3dBlock.clear();
    }

    pub fn has_vector3dBlock(&self) -> bool {
        self.vector3dBlock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vector3dBlock(&mut self, v: Vector3dBlock) {
        self.vector3dBlock = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vector3dBlock(&mut self) -> &mut Vector3dBlock {
        if self.vector3dBlock.is_none() {
            self.vector3dBlock.set_default();
        }
        self.vector3dBlock.as_mut().unwrap()
    }

    // Take field
    pub fn take_vector3dBlock(&mut self) -> Vector3dBlock {
        self.vector3dBlock.take().unwrap_or_else(|| Vector3dBlock::new())
    }

    // required .frontend_pbf.Vector2dBlock vector2dBlock = 2;


    pub fn get_vector2dBlock(&self) -> &Vector2dBlock {
        self.vector2dBlock.as_ref().unwrap_or_else(|| <Vector2dBlock as ::protobuf::Message>::default_instance())
    }
    pub fn clear_vector2dBlock(&mut self) {
        self.vector2dBlock.clear();
    }

    pub fn has_vector2dBlock(&self) -> bool {
        self.vector2dBlock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vector2dBlock(&mut self, v: Vector2dBlock) {
        self.vector2dBlock = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vector2dBlock(&mut self) -> &mut Vector2dBlock {
        if self.vector2dBlock.is_none() {
            self.vector2dBlock.set_default();
        }
        self.vector2dBlock.as_mut().unwrap()
    }

    // Take field
    pub fn take_vector2dBlock(&mut self) -> Vector2dBlock {
        self.vector2dBlock.take().unwrap_or_else(|| Vector2dBlock::new())
    }

    // required .frontend_pbf.StringBlock stringBlock = 3;


    pub fn get_stringBlock(&self) -> &StringBlock {
        self.stringBlock.as_ref().unwrap_or_else(|| <StringBlock as ::protobuf::Message>::default_instance())
    }
    pub fn clear_stringBlock(&mut self) {
        self.stringBlock.clear();
    }

    pub fn has_stringBlock(&self) -> bool {
        self.stringBlock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stringBlock(&mut self, v: StringBlock) {
        self.stringBlock = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stringBlock(&mut self) -> &mut StringBlock {
        if self.stringBlock.is_none() {
            self.stringBlock.set_default();
        }
        self.stringBlock.as_mut().unwrap()
    }

    // Take field
    pub fn take_stringBlock(&mut self) -> StringBlock {
        self.stringBlock.take().unwrap_or_else(|| StringBlock::new())
    }

    // required .frontend_pbf.ShapeBlock shapeBlock = 4;


    pub fn get_shapeBlock(&self) -> &ShapeBlock {
        self.shapeBlock.as_ref().unwrap_or_else(|| <ShapeBlock as ::protobuf::Message>::default_instance())
    }
    pub fn clear_shapeBlock(&mut self) {
        self.shapeBlock.clear();
    }

    pub fn has_shapeBlock(&self) -> bool {
        self.shapeBlock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shapeBlock(&mut self, v: ShapeBlock) {
        self.shapeBlock = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shapeBlock(&mut self) -> &mut ShapeBlock {
        if self.shapeBlock.is_none() {
            self.shapeBlock.set_default();
        }
        self.shapeBlock.as_mut().unwrap()
    }

    // Take field
    pub fn take_shapeBlock(&mut self) -> ShapeBlock {
        self.shapeBlock.take().unwrap_or_else(|| ShapeBlock::new())
    }

    // required .frontend_pbf.MaterialBlock materialBlock = 5;


    pub fn get_materialBlock(&self) -> &MaterialBlock {
        self.materialBlock.as_ref().unwrap_or_else(|| <MaterialBlock as ::protobuf::Message>::default_instance())
    }
    pub fn clear_materialBlock(&mut self) {
        self.materialBlock.clear();
    }

    pub fn has_materialBlock(&self) -> bool {
        self.materialBlock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_materialBlock(&mut self, v: MaterialBlock) {
        self.materialBlock = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_materialBlock(&mut self) -> &mut MaterialBlock {
        if self.materialBlock.is_none() {
            self.materialBlock.set_default();
        }
        self.materialBlock.as_mut().unwrap()
    }

    // Take field
    pub fn take_materialBlock(&mut self) -> MaterialBlock {
        self.materialBlock.take().unwrap_or_else(|| MaterialBlock::new())
    }

    // required .frontend_pbf.ModelBlock modelBlock = 6;


    pub fn get_modelBlock(&self) -> &ModelBlock {
        self.modelBlock.as_ref().unwrap_or_else(|| <ModelBlock as ::protobuf::Message>::default_instance())
    }
    pub fn clear_modelBlock(&mut self) {
        self.modelBlock.clear();
    }

    pub fn has_modelBlock(&self) -> bool {
        self.modelBlock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modelBlock(&mut self, v: ModelBlock) {
        self.modelBlock = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_modelBlock(&mut self) -> &mut ModelBlock {
        if self.modelBlock.is_none() {
            self.modelBlock.set_default();
        }
        self.modelBlock.as_mut().unwrap()
    }

    // Take field
    pub fn take_modelBlock(&mut self) -> ModelBlock {
        self.modelBlock.take().unwrap_or_else(|| ModelBlock::new())
    }

    // repeated .frontend_pbf.WorldObject objects = 7;


    pub fn get_objects(&self) -> &[WorldObject] {
        &self.objects
    }
    pub fn clear_objects(&mut self) {
        self.objects.clear();
    }

    // Param is passed by value, moved
    pub fn set_objects(&mut self, v: ::protobuf::RepeatedField<WorldObject>) {
        self.objects = v;
    }

    // Mutable pointer to the field.
    pub fn mut_objects(&mut self) -> &mut ::protobuf::RepeatedField<WorldObject> {
        &mut self.objects
    }

    // Take field
    pub fn take_objects(&mut self) -> ::protobuf::RepeatedField<WorldObject> {
        ::std::mem::replace(&mut self.objects, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Tile {
    fn is_initialized(&self) -> bool {
        if self.vector3dBlock.is_none() {
            return false;
        }
        if self.vector2dBlock.is_none() {
            return false;
        }
        if self.stringBlock.is_none() {
            return false;
        }
        if self.shapeBlock.is_none() {
            return false;
        }
        if self.materialBlock.is_none() {
            return false;
        }
        if self.modelBlock.is_none() {
            return false;
        }
        for v in &self.vector3dBlock {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.vector2dBlock {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stringBlock {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.shapeBlock {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.materialBlock {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.modelBlock {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.objects {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.vector3dBlock)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.vector2dBlock)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stringBlock)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.shapeBlock)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.materialBlock)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.modelBlock)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.objects)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.vector3dBlock.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.vector2dBlock.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.stringBlock.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.shapeBlock.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.materialBlock.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.modelBlock.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.objects {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.vector3dBlock.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.vector2dBlock.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.stringBlock.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.shapeBlock.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.materialBlock.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.modelBlock.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.objects {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Tile {
        Tile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Vector3dBlock>>(
                "vector3dBlock",
                |m: &Tile| { &m.vector3dBlock },
                |m: &mut Tile| { &mut m.vector3dBlock },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Vector2dBlock>>(
                "vector2dBlock",
                |m: &Tile| { &m.vector2dBlock },
                |m: &mut Tile| { &mut m.vector2dBlock },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StringBlock>>(
                "stringBlock",
                |m: &Tile| { &m.stringBlock },
                |m: &mut Tile| { &mut m.stringBlock },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ShapeBlock>>(
                "shapeBlock",
                |m: &Tile| { &m.shapeBlock },
                |m: &mut Tile| { &mut m.shapeBlock },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MaterialBlock>>(
                "materialBlock",
                |m: &Tile| { &m.materialBlock },
                |m: &mut Tile| { &mut m.materialBlock },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ModelBlock>>(
                "modelBlock",
                |m: &Tile| { &m.modelBlock },
                |m: &mut Tile| { &mut m.modelBlock },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WorldObject>>(
                "objects",
                |m: &Tile| { &m.objects },
                |m: &mut Tile| { &mut m.objects },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Tile>(
                "Tile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Tile {
        static instance: ::protobuf::rt::LazyV2<Tile> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Tile::new)
    }
}

impl ::protobuf::Clear for Tile {
    fn clear(&mut self) {
        self.vector3dBlock.clear();
        self.vector2dBlock.clear();
        self.stringBlock.clear();
        self.shapeBlock.clear();
        self.materialBlock.clear();
        self.modelBlock.clear();
        self.objects.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Tile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Tile {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}


//

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x12frontend_v06.proto\x12\x0cfrontend_pbf\"+\n\rVector3dBlock\x12\x1a\
    \n\x06coords\x18\x01\x20\x03(\x12R\x06coordsB\x02\x10\x01\"+\n\rVector2d\
    Block\x12\x1a\n\x06coords\x18\x01\x20\x03(\x12R\x06coordsB\x02\x10\x01\"\
    '\n\x0bStringBlock\x12\x18\n\x07strings\x18\x01\x20\x03(\tR\x07strings\"\
    9\n\nShapeBlock\x12+\n\x06shapes\x18\x01\x20\x03(\x0b2\x13.frontend_pbf.\
    ShapeR\x06shapes\"\x92\x01\n\x05Shape\x121\n\x04type\x18\x01\x20\x02(\
    \x0e2\x1d.frontend_pbf.Shape.ShapeTypeR\x04type\x12\"\n\nparameters\x18\
    \x02\x20\x03(\x12R\nparametersB\x02\x10\x01\"2\n\tShapeType\x12\n\n\x06C\
    IRCLE\x10\x01\x12\x0b\n\x07POLYGON\x10\x02\x12\x0c\n\x08POLYLINE\x10\x03\
    \"E\n\rMaterialBlock\x124\n\tmaterials\x18\x01\x20\x03(\x0b2\x16.fronten\
    d_pbf.MaterialR\tmaterials\"\x9f\x08\n\x08Material\x12\x1e\n\nbaseColorR\
    \x18\x01\x20\x02(\rR\nbaseColorR\x12\x1e\n\nbaseColorG\x18\x02\x20\x02(\
    \rR\nbaseColorG\x12\x1e\n\nbaseColorB\x18\x03\x20\x02(\rR\nbaseColorB\
    \x12G\n\x0ctextureLayer\x18\x0b\x20\x03(\x0b2#.frontend_pbf.Material.Tex\
    tureLayerR\x0ctextureLayer\x12N\n\x0ctransparency\x18\x10\x20\x01(\x0e2#\
    .frontend_pbf.Material.Transparency:\x05FALSER\x0ctransparency\x12$\n\nc\
    astShadow\x18\x11\x20\x01(\x08:\x04trueR\ncastShadow\x12'\n\x0bdoubleSid\
    ed\x18\x12\x20\x01(\x08:\x05falseR\x0bdoubleSided\x1a\x99\x05\n\x0cTextu\
    reLayer\x120\n\x13baseColorTextureURI\x18\x01\x20\x01(\tR\x13baseColorTe\
    xtureURI\x12$\n\rormTextureURI\x18\x07\x20\x01(\tR\rormTextureURI\x12*\n\
    \x10normalTextureURI\x18\x08\x20\x01(\tR\x10normalTextureURI\x126\n\x16d\
    isplacementTextureURI\x18\t\x20\x01(\tR\x16displacementTextureURI\x12.\n\
    \x12emissiveTextureURI\x18\n\x20\x01(\tR\x12emissiveTextureURI\x126\n\
    \x16reflectivityTextureURI\x18\x0b\x20\x01(\tR\x16reflectivityTextureURI\
    \x12D\n\x04wrap\x18\x02\x20\x01(\x0e2(.frontend_pbf.Material.TextureLaye\
    r.Wrap:\x06REPEATR\x04wrap\x12\x1c\n\tcolorable\x18\x03\x20\x02(\x08R\tc\
    olorable\x12\"\n\x0ctextureWidth\x18\x04\x20\x02(\rR\x0ctextureWidth\x12\
    $\n\rtextureHeight\x18\x05\x20\x02(\rR\rtextureHeight\x12h\n\x10texCoord\
    Function\x18\x06\x20\x01(\x0e24.frontend_pbf.Material.TextureLayer.TexCo\
    ordFunction:\x06CUSTOMR\x10texCoordFunction\"\x1d\n\x04Wrap\x12\n\n\x06R\
    EPEAT\x10\x01\x12\t\n\x05CLAMP\x10\x02\".\n\x10TexCoordFunction\x12\n\n\
    \x06CUSTOM\x10\x01\x12\x0e\n\nGLOBAL_X_Z\x10\x02\"/\n\x0cTransparency\
    \x12\x08\n\x04TRUE\x10\x01\x12\n\n\x06BINARY\x10\x02\x12\t\n\x05FALSE\
    \x10\x03\"?\n\nModelBlock\x121\n\x06models\x18\x01\x20\x03(\x0b2\x19.fro\
    ntend_pbf.WorldObjectR\x06models\"p\n\x10TriangleGeometry\x12\x1a\n\x08m\
    aterial\x18\x01\x20\x02(\rR\x08material\x12\x1e\n\x08vertices\x18\x02\
    \x20\x03(\x04R\x08verticesB\x02\x10\x01\x12\x20\n\ttexCoords\x18\x03\x20\
    \x03(\x04R\ttexCoordsB\x02\x10\x01\"\xdd\x01\n\x11ExtrusionGeometry\x12\
    \x1a\n\x08material\x18\x01\x20\x02(\rR\x08material\x12\x14\n\x05shape\
    \x18\x02\x20\x02(\rR\x05shape\x12\x12\n\x04path\x18\x03\x20\x03(\x04R\
    \x04path\x12\x1c\n\tupVectors\x18\x04\x20\x03(\x04R\tupVectors\x12\"\n\
    \x0cscaleFactors\x18\x05\x20\x03(\x04R\x0cscaleFactors\x12!\n\x08startCa\
    p\x18\x07\x20\x01(\x08:\x05falseR\x08startCap\x12\x1d\n\x06endCap\x18\
    \x08\x20\x01(\x08:\x05falseR\x06endCap\"\xeb\x01\n\x10InstanceGeometry\
    \x12\x14\n\x05model\x18\x01\x20\x01(\rR\x05model\x12.\n\x12resourceIdent\
    ifier\x18\x05\x20\x01(\tR\x12resourceIdentifier\x12\x1e\n\x08position\
    \x18\x02\x20\x03(\x12R\x08positionB\x02\x10\x01\x12\x20\n\tdirection\x18\
    \x03\x20\x03(\x05R\tdirectionB\x02\x10\x01\x12\x18\n\x05scale\x18\x04\
    \x20\x03(\rR\x05scaleB\x02\x10\x01\x125\n\tanimation\x18\x06\x20\x01(\
    \x0b2\x17.frontend_pbf.AnimationR\tanimation\"\xd3\x02\n\tAnimation\x129\
    \n\x04type\x18\x01\x20\x02(\x0e2%.frontend_pbf.Animation.AnimationTypeR\
    \x04type\x12C\n\x08loopMode\x18\x02\x20\x01(\x0e2\x20.frontend_pbf.Anima\
    tion.LoopMode:\x05CYCLER\x08loopMode\x12K\n\ttimerType\x18\x03\x20\x01(\
    \x0e2!.frontend_pbf.Animation.TimerType:\nMODEL_TIMER\ttimerType\x12$\n\
    \rrunsPerSecond\x18\x04\x20\x02(\x01R\rrunsPerSecond\"\x1f\n\rAnimationT\
    ype\x12\x0e\n\nROTATION_X\x10\x01\"\x15\n\x08LoopMode\x12\t\n\x05CYCLE\
    \x10\x01\"\x1b\n\tTimerType\x12\x0e\n\nMODEL_TIME\x10\x01\"\xe8\x02\n\
    \x0bWorldObject\x12\x14\n\x05osmId\x18\x01\x20\x01(\tR\x05osmId\x12\x1a\
    \n\x08typeName\x18\x02\x20\x01(\rR\x08typeName\x12N\n\x12triangleGeometr\
    ies\x18\x03\x20\x03(\x0b2\x1e.frontend_pbf.TriangleGeometryR\x12triangle\
    Geometries\x12Q\n\x13extrusionGeometries\x18\x04\x20\x03(\x0b2\x1f.front\
    end_pbf.ExtrusionGeometryR\x13extrusionGeometries\x12N\n\x12instanceGeom\
    etries\x18\x05\x20\x03(\x0b2\x1e.frontend_pbf.InstanceGeometryR\x12insta\
    nceGeometries\x12\x19\n\x06minLod\x18\x06\x20\x01(\r:\x010R\x06minLod\
    \x12\x19\n\x06maxLod\x18\x07\x20\x01(\r:\x014R\x06maxLod\"\xb5\x03\n\x04\
    Tile\x12A\n\rvector3dBlock\x18\x01\x20\x02(\x0b2\x1b.frontend_pbf.Vector\
    3dBlockR\rvector3dBlock\x12A\n\rvector2dBlock\x18\x02\x20\x02(\x0b2\x1b.\
    frontend_pbf.Vector2dBlockR\rvector2dBlock\x12;\n\x0bstringBlock\x18\x03\
    \x20\x02(\x0b2\x19.frontend_pbf.StringBlockR\x0bstringBlock\x128\n\nshap\
    eBlock\x18\x04\x20\x02(\x0b2\x18.frontend_pbf.ShapeBlockR\nshapeBlock\
    \x12A\n\rmaterialBlock\x18\x05\x20\x02(\x0b2\x1b.frontend_pbf.MaterialBl\
    ockR\rmaterialBlock\x128\n\nmodelBlock\x18\x06\x20\x02(\x0b2\x18.fronten\
    d_pbf.ModelBlockR\nmodelBlock\x123\n\x07objects\x18\x07\x20\x03(\x0b2\
    \x19.frontend_pbf.WorldObjectR\x07objectsB5\n&org.osm2world.core.target.\
    frontend_pbfB\x0bFrontendPbfJ\xf4e\n\x07\x12\x05\0\0\xcf\x02\x01\n\x08\n\
    \x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x02\0\x15\n\x08\n\x01\
    \x08\x12\x03\x04\0?\n\t\n\x02\x08\x01\x12\x03\x04\0?\n\x08\n\x01\x08\x12\
    \x03\x05\0,\n\t\n\x02\x08\x08\x12\x03\x05\0,\n\xd2\x02\n\x02\x04\0\x12\
    \x04\x0c\0\x10\x01\x1a\xc5\x02\x20a\x20block\x20containing\x20all\x20thr\
    ee-dimensional\x20vectors\x20used\x20in\x20the\x20tile.\n\x20Vectors\x20\
    are\x20referenced\x20via\x20their\x20position\x20in\x20this\x20block.\n\
    \x20Values\x20are\x20in\x20millimeters\x20relative\x20to\x20the\x20cente\
    r\x20of\x20the\x20tile.\n\x20The\x20first\x203\x20values\x20are\x20x,\
    \x20y,\x20and\x20z\x20coordinates\x20of\x20the\x20first\x20vector,\x20et\
    c.\n\x20Therefore,\x20the\x20number\x20of\x20coordinates\x20must\x20be\
    \x20divisible\x20by\x203.\x20\n\n\n\x03\x04\0\x01\x12\x03\x0c\x08\x15\n\
    \x0b\n\x04\x04\0\x02\0\x12\x03\x0e\x081\n\x0c\n\x05\x04\0\x02\0\x04\x12\
    \x03\x0e\x08\x10\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\x0e\x11\x17\n\x0c\n\
    \x05\x04\0\x02\0\x01\x12\x03\x0e\x18\x1e\n\x0c\n\x05\x04\0\x02\0\x03\x12\
    \x03\x0e!\"\n\x0c\n\x05\x04\0\x02\0\x08\x12\x03\x0e#0\n\r\n\x06\x04\0\
    \x02\0\x08\x02\x12\x03\x0e$/\n\x9a\x01\n\x02\x04\x01\x12\x04\x15\0\x19\
    \x01\x1a\x8d\x01\x20a\x20block\x20containing\x20all\x20two-dimensional\
    \x20vectors\x20used\x20in\x20the\x20tile.\n\x20See\x20Vector3dBlock\x20f\
    or\x20more\x20details.\n\x20All\x20values\x20are\x20multiplied\x20with\
    \x201000.\x20\n\n\n\x03\x04\x01\x01\x12\x03\x15\x08\x15\n\x0b\n\x04\x04\
    \x01\x02\0\x12\x03\x17\x081\n\x0c\n\x05\x04\x01\x02\0\x04\x12\x03\x17\
    \x08\x10\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03\x17\x11\x17\n\x0c\n\x05\
    \x04\x01\x02\0\x01\x12\x03\x17\x18\x1e\n\x0c\n\x05\x04\x01\x02\0\x03\x12\
    \x03\x17!\"\n\x0c\n\x05\x04\x01\x02\0\x08\x12\x03\x17#0\n\r\n\x06\x04\
    \x01\x02\0\x08\x02\x12\x03\x17$/\nJ\n\x02\x04\x02\x12\x04\x1c\0\x20\x01\
    \x1a>\x20a\x20block\x20containing\x20strings\x20referenced\x20elsewhere\
    \x20in\x20the\x20tile.\x20\n\n\n\x03\x04\x02\x01\x12\x03\x1c\x08\x13\n\
    \x0b\n\x04\x04\x02\x02\0\x12\x03\x1e\x08$\n\x0c\n\x05\x04\x02\x02\0\x04\
    \x12\x03\x1e\x08\x10\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03\x1e\x11\x17\n\
    \x0c\n\x05\x04\x02\x02\0\x01\x12\x03\x1e\x18\x1f\n\x0c\n\x05\x04\x02\x02\
    \0\x03\x12\x03\x1e\"#\n@\n\x02\x04\x03\x12\x04#\0'\x01\x1a4\x20a\x20bloc\
    k\x20containing\x20all\x202d\x20shapes\x20used\x20in\x20the\x20tile.\x20\
    \n\n\n\x03\x04\x03\x01\x12\x03#\x08\x12\n\x0b\n\x04\x04\x03\x02\0\x12\
    \x03%\x08\"\n\x0c\n\x05\x04\x03\x02\0\x04\x12\x03%\x08\x10\n\x0c\n\x05\
    \x04\x03\x02\0\x06\x12\x03%\x11\x16\n\x0c\n\x05\x04\x03\x02\0\x01\x12\
    \x03%\x17\x1d\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03%\x20!\n\x18\n\x02\
    \x04\x04\x12\x04*\0C\x01\x1a\x0c\x20a\x202d\x20shape\x20\n\n\n\x03\x04\
    \x04\x01\x12\x03*\x08\r\n\x0c\n\x04\x04\x04\x04\0\x12\x04,\x08;\t\n\x0c\
    \n\x05\x04\x04\x04\0\x01\x12\x03,\r\x16\n\x8c\x01\n\x06\x04\x04\x04\0\
    \x02\0\x12\x033\x10\x1b\x1a}\n\x20a\x20circle.\x20There\x20are\x20only\
    \x20two\x20parameters:\n\x20-\x20the\x20center,\x20as\x20a\x20reference\
    \x20to\x20the\x20vector2dBlock\n\x20-\x20the\x20radius,\x20in\x20millime\
    ters.\n\n\x0e\n\x07\x04\x04\x04\0\x02\0\x01\x12\x033\x10\x16\n\x0e\n\x07\
    \x04\x04\x04\0\x02\0\x02\x12\x033\x19\x1a\n\x90\x01\n\x06\x04\x04\x04\0\
    \x02\x01\x12\x036\x10\x1c\x1a\x80\x01\x20a\x20closed\x20polygon.\x20The\
    \x20parameters\x20represent\x20a\x20series\x20of\x202d\x20vectors\x20(x0\
    ,\x20y0,\x20x1,\x20y1,\x20...).\x20Vector\x20components\x20are\x20in\x20\
    millimeters.\x20\n\x0e\n\x07\x04\x04\x04\0\x02\x01\x01\x12\x036\x10\x17\
    \n\x0e\n\x07\x04\x04\x04\0\x02\x01\x02\x12\x036\x1a\x1b\n\x89\x01\n\x06\
    \x04\x04\x04\0\x02\x02\x12\x039\x10\x1d\x1az\x20a\x20polyline.\x20The\
    \x20parameters\x20represent\x20a\x20series\x20of\x202d\x20vectors\x20(x0\
    ,\x20y0,\x20x1,\x20y1,\x20...).\x20Vector\x20components\x20are\x20in\x20\
    millimeters.\x20\n\x0e\n\x07\x04\x04\x04\0\x02\x02\x01\x12\x039\x10\x18\
    \n\x0e\n\x07\x04\x04\x04\0\x02\x02\x02\x12\x039\x1b\x1c\n\x0b\n\x04\x04\
    \x04\x02\0\x12\x03=\x08$\n\x0c\n\x05\x04\x04\x02\0\x04\x12\x03=\x08\x10\
    \n\x0c\n\x05\x04\x04\x02\0\x06\x12\x03=\x11\x1a\n\x0c\n\x05\x04\x04\x02\
    \0\x01\x12\x03=\x1b\x1f\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03=\"#\nw\n\
    \x04\x04\x04\x02\x01\x12\x03A\x087\x1aj\x20parameters\x20for\x20the\x20s\
    hape,\x20such\x20as\x20the\x20radius\x20of\x20a\x20circle.\nThe\x20preci\
    se\x20meaning\x20depends\x20on\x20the\x20shape\x20type!\x20\n\x0c\n\x05\
    \x04\x04\x02\x01\x04\x12\x03A\x08\x10\n\x0c\n\x05\x04\x04\x02\x01\x05\
    \x12\x03A\x11\x17\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\x03A\x18\"\n\x0c\n\
    \x05\x04\x04\x02\x01\x03\x12\x03A%&\n\x0c\n\x05\x04\x04\x02\x01\x08\x12\
    \x03A'6\n\r\n\x06\x04\x04\x02\x01\x08\x02\x12\x03A(5\n@\n\x02\x04\x05\
    \x12\x04F\0J\x01\x1a4\x20a\x20block\x20containing\x20all\x20materials\
    \x20used\x20in\x20the\x20tile.\x20\n\n\n\x03\x04\x05\x01\x12\x03F\x08\
    \x15\n\x0b\n\x04\x04\x05\x02\0\x12\x03H\x08(\n\x0c\n\x05\x04\x05\x02\0\
    \x04\x12\x03H\x08\x10\n\x0c\n\x05\x04\x05\x02\0\x06\x12\x03H\x11\x19\n\
    \x0c\n\x05\x04\x05\x02\0\x01\x12\x03H\x1a#\n\x0c\n\x05\x04\x05\x02\0\x03\
    \x12\x03H&'\nk\n\x02\x04\x06\x12\x05N\0\xa4\x01\x01\x1a^\x20a\x20set\x20\
    of\x20material\x20properties,\x20using\x20RGB\x20colors.\n\x20Color\x20c\
    omponents\x20are\x20in\x20the\x20range\x20[0,\x20255].\x20\n\n\n\x03\x04\
    \x06\x01\x12\x03N\x08\x10\n\x0c\n\x04\x04\x06\x04\0\x12\x04P\x08[\t\n\
    \x0c\n\x05\x04\x06\x04\0\x01\x12\x03P\r\x19\nO\n\x06\x04\x06\x04\0\x02\0\
    \x12\x03S\x10\x19\x1a@\x20arbitrary\x20transparency,\x20including\x20par\
    tially\x20transparent\x20pixels\x20\n\x0e\n\x07\x04\x06\x04\0\x02\0\x01\
    \x12\x03S\x10\x14\n\x0e\n\x07\x04\x06\x04\0\x02\0\x02\x12\x03S\x17\x18\n\
    Q\n\x06\x04\x06\x04\0\x02\x01\x12\x03V\x10\x1b\x1aB\x20only\x20allow\x20\
    pixels\x20to\x20be\x20either\x20fully\x20transparent\x20or\x20fully\x20o\
    paque\x20\n\x0e\n\x07\x04\x06\x04\0\x02\x01\x01\x12\x03V\x10\x16\n\x0e\n\
    \x07\x04\x06\x04\0\x02\x01\x02\x12\x03V\x19\x1a\n&\n\x06\x04\x06\x04\0\
    \x02\x02\x12\x03Y\x10\x1a\x1a\x17\x20all\x20pixels\x20are\x20opaque\x20\
    \n\x0e\n\x07\x04\x06\x04\0\x02\x02\x01\x12\x03Y\x10\x15\n\x0e\n\x07\x04\
    \x06\x04\0\x02\x02\x02\x12\x03Y\x18\x19\n\x8b\x01\n\x04\x04\x06\x03\0\
    \x12\x05^\x08\x90\x01\t\x1a|*\x20a\x20set\x20of\x20PBR\x20textures\x20re\
    presenting\x20one\x20layer\x20of\x20the\x20material.\x20All\x20textures\
    \x20in\x20the\x20layer\x20use\x20the\x20same\x20texture\x20coordinates.\
    \x20\n\x0c\n\x05\x04\x06\x03\0\x01\x12\x03^\x10\x1c\n\x0e\n\x06\x04\x06\
    \x03\0\x04\0\x12\x04`\x10c\x11\n\x0e\n\x07\x04\x06\x03\0\x04\0\x01\x12\
    \x03`\x15\x19\n\x0f\n\x08\x04\x06\x03\0\x04\0\x02\0\x12\x03a\x18#\n\x10\
    \n\t\x04\x06\x03\0\x04\0\x02\0\x01\x12\x03a\x18\x1e\n\x10\n\t\x04\x06\
    \x03\0\x04\0\x02\0\x02\x12\x03a!\"\n\x0f\n\x08\x04\x06\x03\0\x04\0\x02\
    \x01\x12\x03b\x18\"\n\x10\n\t\x04\x06\x03\0\x04\0\x02\x01\x01\x12\x03b\
    \x18\x1d\n\x10\n\t\x04\x06\x03\0\x04\0\x02\x01\x02\x12\x03b\x20!\n\x0e\n\
    \x06\x04\x06\x03\0\x04\x01\x12\x04e\x10m\x11\n\x0e\n\x07\x04\x06\x03\0\
    \x04\x01\x01\x12\x03e\x15%\n|\n\x08\x04\x06\x03\0\x04\x01\x02\0\x12\x03h\
    \x18#\x1ak\x20No\x20standard\x20function\x20is\x20used.\x20Texture\x20co\
    ordinates\x20for\x20this\x20layer\x20will\x20be\x20provided\x20alongside\
    \x20the\x20geometry.\x20\n\x10\n\t\x04\x06\x03\0\x04\x01\x02\0\x01\x12\
    \x03h\x18\x1e\n\x10\n\t\x04\x06\x03\0\x04\x01\x02\0\x02\x12\x03h!\"\nm\n\
    \x08\x04\x06\x03\0\x04\x01\x02\x01\x12\x03k\x18'\x1a\\\x20uses\x20x\x20a\
    nd\x20z\x20vertex\x20coords\x20together\x20with\x20the\x20texture's\x20w\
    idth\x20and\x20height\x20to\x20place\x20a\x20texture\x20\n\x10\n\t\x04\
    \x06\x03\0\x04\x01\x02\x01\x01\x12\x03k\x18\"\n\x10\n\t\x04\x06\x03\0\
    \x04\x01\x02\x01\x02\x12\x03k%&\n`\n\x06\x04\x06\x03\0\x02\0\x12\x03p\
    \x108\x1aQ\x20URI\x20of\x20the\x20base\x20color\x20+\x20alpha\x20texture\
    \x20image,\x20can\x20be\x20relative,\x20can\x20be\x20a\x20data\x20URI\
    \x20\n\x0e\n\x07\x04\x06\x03\0\x02\0\x04\x12\x03p\x10\x18\n\x0e\n\x07\
    \x04\x06\x03\0\x02\0\x05\x12\x03p\x19\x1f\n\x0e\n\x07\x04\x06\x03\0\x02\
    \0\x01\x12\x03p\x203\n\x0e\n\x07\x04\x06\x03\0\x02\0\x03\x12\x03p67\nk\n\
    \x06\x04\x06\x03\0\x02\x01\x12\x03s\x102\x1a\\\x20URI\x20of\x20the\x20oc\
    clusion/roughness/metalness\x20texture\x20image,\x20can\x20be\x20relativ\
    e,\x20can\x20be\x20a\x20data\x20URI\x20\n\x0e\n\x07\x04\x06\x03\0\x02\
    \x01\x04\x12\x03s\x10\x18\n\x0e\n\x07\x04\x06\x03\0\x02\x01\x05\x12\x03s\
    \x19\x1f\n\x0e\n\x07\x04\x06\x03\0\x02\x01\x01\x12\x03s\x20-\n\x0e\n\x07\
    \x04\x06\x03\0\x02\x01\x03\x12\x03s01\nX\n\x06\x04\x06\x03\0\x02\x02\x12\
    \x03v\x105\x1aI\x20URI\x20of\x20the\x20normal\x20map\x20texture\x20image\
    ,\x20can\x20be\x20relative,\x20can\x20be\x20a\x20data\x20URI\x20\n\x0e\n\
    \x07\x04\x06\x03\0\x02\x02\x04\x12\x03v\x10\x18\n\x0e\n\x07\x04\x06\x03\
    \0\x02\x02\x05\x12\x03v\x19\x1f\n\x0e\n\x07\x04\x06\x03\0\x02\x02\x01\
    \x12\x03v\x200\n\x0e\n\x07\x04\x06\x03\0\x02\x02\x03\x12\x03v34\n^\n\x06\
    \x04\x06\x03\0\x02\x03\x12\x03y\x10;\x1aO\x20URI\x20of\x20the\x20displac\
    ement\x20map\x20texture\x20image,\x20can\x20be\x20relative,\x20can\x20be\
    \x20a\x20data\x20URI\x20\n\x0e\n\x07\x04\x06\x03\0\x02\x03\x04\x12\x03y\
    \x10\x18\n\x0e\n\x07\x04\x06\x03\0\x02\x03\x05\x12\x03y\x19\x1f\n\x0e\n\
    \x07\x04\x06\x03\0\x02\x03\x01\x12\x03y\x206\n\x0e\n\x07\x04\x06\x03\0\
    \x02\x03\x03\x12\x03y9:\nV\n\x06\x04\x06\x03\0\x02\x04\x12\x03|\x108\x1a\
    G\x20URI\x20of\x20the\x20emissive\x20texture\x20image,\x20can\x20be\x20r\
    elative,\x20can\x20be\x20a\x20data\x20URI\x20\n\x0e\n\x07\x04\x06\x03\0\
    \x02\x04\x04\x12\x03|\x10\x18\n\x0e\n\x07\x04\x06\x03\0\x02\x04\x05\x12\
    \x03|\x19\x1f\n\x0e\n\x07\x04\x06\x03\0\x02\x04\x01\x12\x03|\x202\n\x0e\
    \n\x07\x04\x06\x03\0\x02\x04\x03\x12\x03|57\nZ\n\x06\x04\x06\x03\0\x02\
    \x05\x12\x03\x7f\x10<\x1aK\x20URI\x20of\x20the\x20reflectivity\x20textur\
    e\x20image,\x20can\x20be\x20relative,\x20can\x20be\x20a\x20data\x20URI\
    \x20\n\x0e\n\x07\x04\x06\x03\0\x02\x05\x04\x12\x03\x7f\x10\x18\n\x0e\n\
    \x07\x04\x06\x03\0\x02\x05\x05\x12\x03\x7f\x19\x1f\n\x0e\n\x07\x04\x06\
    \x03\0\x02\x05\x01\x12\x03\x7f\x206\n\x0e\n\x07\x04\x06\x03\0\x02\x05\
    \x03\x12\x03\x7f9;\n`\n\x06\x04\x06\x03\0\x02\x06\x12\x04\x83\x01\x10:\
    \x1aP\x20how\x20the\x20texture\x20behaves\x20for\x20texture\x20coordinat\
    es\n\x20less\x20than\x200\x20or\x20greater\x20than\x201\x20\n\x0f\n\x07\
    \x04\x06\x03\0\x02\x06\x04\x12\x04\x83\x01\x10\x18\n\x0f\n\x07\x04\x06\
    \x03\0\x02\x06\x06\x12\x04\x83\x01\x19\x1d\n\x0f\n\x07\x04\x06\x03\0\x02\
    \x06\x01\x12\x04\x83\x01\x1e\"\n\x0f\n\x07\x04\x06\x03\0\x02\x06\x03\x12\
    \x04\x83\x01%&\n\x0f\n\x07\x04\x06\x03\0\x02\x06\x08\x12\x04\x83\x01'9\n\
    \x0f\n\x07\x04\x06\x03\0\x02\x06\x07\x12\x04\x83\x0128\nj\n\x06\x04\x06\
    \x03\0\x02\x07\x12\x04\x86\x01\x10,\x1aZ\x20whether\x20the\x20base\x20co\
    lor\x20texture\x20should\x20be\x20multiplied\x20with\x20the\x20material'\
    s\x20base\x20color\x20value\x20\n\x0f\n\x07\x04\x06\x03\0\x02\x07\x04\
    \x12\x04\x86\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\0\x02\x07\x05\x12\x04\
    \x86\x01\x19\x1d\n\x0f\n\x07\x04\x06\x03\0\x02\x07\x01\x12\x04\x86\x01\
    \x1e'\n\x0f\n\x07\x04\x06\x03\0\x02\x07\x03\x12\x04\x86\x01*+\n6\n\x06\
    \x04\x06\x03\0\x02\x08\x12\x04\x89\x01\x101\x1a&\x20width\x20of\x20the\
    \x20texture\x20in\x20millimeters.\x20\n\x0f\n\x07\x04\x06\x03\0\x02\x08\
    \x04\x12\x04\x89\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\0\x02\x08\x05\x12\
    \x04\x89\x01\x19\x1f\n\x0f\n\x07\x04\x06\x03\0\x02\x08\x01\x12\x04\x89\
    \x01\x20,\n\x0f\n\x07\x04\x06\x03\0\x02\x08\x03\x12\x04\x89\x01/0\n7\n\
    \x06\x04\x06\x03\0\x02\t\x12\x04\x8c\x01\x102\x1a'\x20height\x20of\x20th\
    e\x20texture\x20in\x20millimeters.\x20\n\x0f\n\x07\x04\x06\x03\0\x02\t\
    \x04\x12\x04\x8c\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\0\x02\t\x05\x12\x04\
    \x8c\x01\x19\x1f\n\x0f\n\x07\x04\x06\x03\0\x02\t\x01\x12\x04\x8c\x01\x20\
    -\n\x0f\n\x07\x04\x06\x03\0\x02\t\x03\x12\x04\x8c\x0101\n\x0e\n\x06\x04\
    \x06\x03\0\x02\n\x12\x04\x8e\x01\x10R\n\x0f\n\x07\x04\x06\x03\0\x02\n\
    \x04\x12\x04\x8e\x01\x10\x18\n\x0f\n\x07\x04\x06\x03\0\x02\n\x06\x12\x04\
    \x8e\x01\x19)\n\x0f\n\x07\x04\x06\x03\0\x02\n\x01\x12\x04\x8e\x01*:\n\
    \x0f\n\x07\x04\x06\x03\0\x02\n\x03\x12\x04\x8e\x01=>\n\x0f\n\x07\x04\x06\
    \x03\0\x02\n\x08\x12\x04\x8e\x01?Q\n\x0f\n\x07\x04\x06\x03\0\x02\n\x07\
    \x12\x04\x8e\x01JP\n\x0c\n\x04\x04\x06\x02\0\x12\x04\x92\x01\x08'\n\r\n\
    \x05\x04\x06\x02\0\x04\x12\x04\x92\x01\x08\x10\n\r\n\x05\x04\x06\x02\0\
    \x05\x12\x04\x92\x01\x11\x17\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\x92\x01\
    \x18\"\n\r\n\x05\x04\x06\x02\0\x03\x12\x04\x92\x01%&\n\x0c\n\x04\x04\x06\
    \x02\x01\x12\x04\x93\x01\x08'\n\r\n\x05\x04\x06\x02\x01\x04\x12\x04\x93\
    \x01\x08\x10\n\r\n\x05\x04\x06\x02\x01\x05\x12\x04\x93\x01\x11\x17\n\r\n\
    \x05\x04\x06\x02\x01\x01\x12\x04\x93\x01\x18\"\n\r\n\x05\x04\x06\x02\x01\
    \x03\x12\x04\x93\x01%&\n\x0c\n\x04\x04\x06\x02\x02\x12\x04\x94\x01\x08'\
    \n\r\n\x05\x04\x06\x02\x02\x04\x12\x04\x94\x01\x08\x10\n\r\n\x05\x04\x06\
    \x02\x02\x05\x12\x04\x94\x01\x11\x17\n\r\n\x05\x04\x06\x02\x02\x01\x12\
    \x04\x94\x01\x18\"\n\r\n\x05\x04\x06\x02\x02\x03\x12\x04\x94\x01%&\n:\n\
    \x04\x04\x06\x02\x03\x12\x04\x97\x01\x080\x1a,\x20texture\x20layers,\x20\
    ordered\x20from\x20bottom\x20to\x20top\x20\n\r\n\x05\x04\x06\x02\x03\x04\
    \x12\x04\x97\x01\x08\x10\n\r\n\x05\x04\x06\x02\x03\x06\x12\x04\x97\x01\
    \x11\x1d\n\r\n\x05\x04\x06\x02\x03\x01\x12\x04\x97\x01\x1e*\n\r\n\x05\
    \x04\x06\x02\x03\x03\x12\x04\x97\x01-/\n(\n\x04\x04\x06\x02\x04\x12\x04\
    \x9a\x01\x08B\x1a\x1a\x20the\x20type\x20of\x20transparency\x20\n\r\n\x05\
    \x04\x06\x02\x04\x04\x12\x04\x9a\x01\x08\x10\n\r\n\x05\x04\x06\x02\x04\
    \x06\x12\x04\x9a\x01\x11\x1d\n\r\n\x05\x04\x06\x02\x04\x01\x12\x04\x9a\
    \x01\x1e*\n\r\n\x05\x04\x06\x02\x04\x03\x12\x04\x9a\x01-/\n\r\n\x05\x04\
    \x06\x02\x04\x08\x12\x04\x9a\x010A\n\r\n\x05\x04\x06\x02\x04\x07\x12\x04\
    \x9a\x01;@\n3\n\x04\x04\x06\x02\x05\x12\x04\x9d\x01\x087\x1a%\x20whether\
    \x20this\x20material\x20casts\x20shadows\x20\n\r\n\x05\x04\x06\x02\x05\
    \x04\x12\x04\x9d\x01\x08\x10\n\r\n\x05\x04\x06\x02\x05\x05\x12\x04\x9d\
    \x01\x11\x15\n\r\n\x05\x04\x06\x02\x05\x01\x12\x04\x9d\x01\x16\x20\n\r\n\
    \x05\x04\x06\x02\x05\x03\x12\x04\x9d\x01#%\n\r\n\x05\x04\x06\x02\x05\x08\
    \x12\x04\x9d\x01&6\n\r\n\x05\x04\x06\x02\x05\x07\x12\x04\x9d\x0115\n\x91\
    \x01\n\x04\x04\x06\x02\x06\x12\x04\xa2\x01\x089\x1a\x82\x01\x20whether\
    \x20this\x20material\x20is\x20double-sided.\n\x20If\x20true,\x20backface\
    \x20culling\x20should\x20be\x20disabled,\n\x20and\x20two-sided\x20lighti\
    ng\x20should\x20be\x20enabled.\x20\n\r\n\x05\x04\x06\x02\x06\x04\x12\x04\
    \xa2\x01\x08\x10\n\r\n\x05\x04\x06\x02\x06\x05\x12\x04\xa2\x01\x11\x15\n\
    \r\n\x05\x04\x06\x02\x06\x01\x12\x04\xa2\x01\x16!\n\r\n\x05\x04\x06\x02\
    \x06\x03\x12\x04\xa2\x01$&\n\r\n\x05\x04\x06\x02\x06\x08\x12\x04\xa2\x01\
    '8\n\r\n\x05\x04\x06\x02\x06\x07\x12\x04\xa2\x0127\n\xc2\x01\n\x02\x04\
    \x07\x12\x06\xa9\x01\0\xae\x01\x01\x1a\xb3\x01\x20a\x20block\x20containi\
    ng\x20all\x20template\x20models\x20used\x20in\x20this\x20file.\n\x20Each\
    \x20model\x20is\x20represented\x20as\x20a\x20WorldObject\x20with\x20no\
    \x20id\x20or\x20type.\n\x20A\x20template\x20model\x20must\x20not\x20use\
    \x20InstanceGeometry\x20itself.\x20\n\x0b\n\x03\x04\x07\x01\x12\x04\xa9\
    \x01\x08\x12\ne\n\x04\x04\x07\x02\0\x12\x04\xac\x01\x08(\x1aW\x20the\x20\
    template\x20models\x20that\x20can\x20be\x20copied\x20(with\x20slight\x20\
    variations)\x20in\x20multiple\x20locations\x20\n\r\n\x05\x04\x07\x02\0\
    \x04\x12\x04\xac\x01\x08\x10\n\r\n\x05\x04\x07\x02\0\x06\x12\x04\xac\x01\
    \x11\x1c\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\xac\x01\x1d#\n\r\n\x05\x04\
    \x07\x02\0\x03\x12\x04\xac\x01&'\n9\n\x02\x04\x08\x12\x06\xb1\x01\0\xc4\
    \x01\x01\x1a+\x20geometry\x20consisting\x20of\x20a\x20set\x20of\x20trian\
    gles\x20\n\x0b\n\x03\x04\x08\x01\x12\x04\xb1\x01\x08\x18\nB\n\x04\x04\
    \x08\x02\0\x12\x04\xb4\x01\x08%\x1a4\x20the\x20geometry's\x20material,\
    \x20referencing\x20materialBlock\x20\n\r\n\x05\x04\x08\x02\0\x04\x12\x04\
    \xb4\x01\x08\x10\n\r\n\x05\x04\x08\x02\0\x05\x12\x04\xb4\x01\x11\x17\n\r\
    \n\x05\x04\x08\x02\0\x01\x12\x04\xb4\x01\x18\x20\n\r\n\x05\x04\x08\x02\0\
    \x03\x12\x04\xb4\x01#$\n\x9e\x01\n\x04\x04\x08\x02\x01\x12\x04\xb9\x01\
    \x085\x1a\x8f\x01\x20vertices\x20of\x20the\x20triangles,\x20represented\
    \x20as\n\x203\x20references\x20to\x20the\x20Vector3d\x20block\x20each.\n\
    \x20At\x20least\x201\x20triangle\x20(i.e.\x203\x20vertex\x20references)\
    \x20required.\x20\n\r\n\x05\x04\x08\x02\x01\x04\x12\x04\xb9\x01\x08\x10\
    \n\r\n\x05\x04\x08\x02\x01\x05\x12\x04\xb9\x01\x11\x17\n\r\n\x05\x04\x08\
    \x02\x01\x01\x12\x04\xb9\x01\x18\x20\n\r\n\x05\x04\x08\x02\x01\x03\x12\
    \x04\xb9\x01#$\n\r\n\x05\x04\x08\x02\x01\x08\x12\x04\xb9\x01%4\n\x0e\n\
    \x06\x04\x08\x02\x01\x08\x02\x12\x04\xb9\x01&3\n\x8c\x03\n\x04\x04\x08\
    \x02\x02\x12\x04\xc2\x01\x086\x1a\xfd\x02\x20texture\x20coordinates\x20f\
    or\x20each\x20vertex\x20of\x20the\x20triangles,\n\x20referencing\x20the\
    \x20Vector2d\x20block.\n\x20Texture\x20coordinates\x20are\x20only\x20pro\
    vided\x20for\x20those\x20layers\n\x20which\x20are\x20using\x20the\x20CUS\
    TOM\x20texture\x20coordinate\x20function\x20(see\x20Material).\n\x20The\
    \x20length\x20of\x20this\x20list\x20is\x20that\x20of\n\x20vertices,\x20t\
    imes\x20the\x20number\x20of\x20CUSTOM-coordinated\x20texture\x20layers.\
    \n\x20Starts\x20with\x20all\x20vertices'\x20tex\x20coords\x20for\x20laye\
    r\x200,\x20then\x201\x20etc.\x20\n\r\n\x05\x04\x08\x02\x02\x04\x12\x04\
    \xc2\x01\x08\x10\n\r\n\x05\x04\x08\x02\x02\x05\x12\x04\xc2\x01\x11\x17\n\
    \r\n\x05\x04\x08\x02\x02\x01\x12\x04\xc2\x01\x18!\n\r\n\x05\x04\x08\x02\
    \x02\x03\x12\x04\xc2\x01$%\n\r\n\x05\x04\x08\x02\x02\x08\x12\x04\xc2\x01\
    &5\n\x0e\n\x06\x04\x08\x02\x02\x08\x02\x12\x04\xc2\x01'4\n\x90\x01\n\x02\
    \x04\t\x12\x06\xc8\x01\0\xdc\x01\x01\x1a\x81\x01\x20geometry\x20produced\
    \x20by\x20extruding\x20a\x202d\x20shape.\nSee\x20OSM2World's\x20Target.d\
    rawExtrudedShape\x20method\x20for\x20documentation\x20of\x20the\x20param\
    eters.\x20\n\x0b\n\x03\x04\t\x01\x12\x04\xc8\x01\x08\x19\nB\n\x04\x04\t\
    \x02\0\x12\x04\xcb\x01\x08%\x1a4\x20the\x20geometry's\x20material,\x20re\
    ferencing\x20materialBlock\x20\n\r\n\x05\x04\t\x02\0\x04\x12\x04\xcb\x01\
    \x08\x10\n\r\n\x05\x04\t\x02\0\x05\x12\x04\xcb\x01\x11\x17\n\r\n\x05\x04\
    \t\x02\0\x01\x12\x04\xcb\x01\x18\x20\n\r\n\x05\x04\t\x02\0\x03\x12\x04\
    \xcb\x01#$\n@\n\x04\x04\t\x02\x01\x12\x04\xce\x01\x08\"\x1a2\x20the\x20s\
    hape\x20to\x20be\x20extruded,\x20referencing\x20shapeBlock\x20\n\r\n\x05\
    \x04\t\x02\x01\x04\x12\x04\xce\x01\x08\x10\n\r\n\x05\x04\t\x02\x01\x05\
    \x12\x04\xce\x01\x11\x17\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\xce\x01\x18\
    \x1d\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\xce\x01\x20!\n)\n\x04\x04\t\x02\
    \x02\x12\x04\xd1\x01\x08!\x1a\x1b\x20referencing\x20vector3dBlock\x20\n\
    \r\n\x05\x04\t\x02\x02\x04\x12\x04\xd1\x01\x08\x10\n\r\n\x05\x04\t\x02\
    \x02\x05\x12\x04\xd1\x01\x11\x17\n\r\n\x05\x04\t\x02\x02\x01\x12\x04\xd1\
    \x01\x18\x1c\n\r\n\x05\x04\t\x02\x02\x03\x12\x04\xd1\x01\x1f\x20\nj\n\
    \x04\x04\t\x02\x03\x12\x04\xd4\x01\x08&\x1a\\\x20referencing\x20vector3d\
    Block.\x20Same\x20length\x20as\x20path.\x20Can\x20be\x20omitted,\x20defa\
    ults\x20to\x20z\x20unit\x20vector.\x20\n\r\n\x05\x04\t\x02\x03\x04\x12\
    \x04\xd4\x01\x08\x10\n\r\n\x05\x04\t\x02\x03\x05\x12\x04\xd4\x01\x11\x17\
    \n\r\n\x05\x04\t\x02\x03\x01\x12\x04\xd4\x01\x18!\n\r\n\x05\x04\t\x02\
    \x03\x03\x12\x04\xd4\x01$%\nt\n\x04\x04\t\x02\x04\x12\x04\xd7\x01\x08)\
    \x1af\x20multiplicative\x20factor,\x20times\x201000.\x20Either\x20omitte\
    d\x20(if\x20no\x20scaling\x20is\x20applied)\x20or\x20same\x20length\x20a\
    s\x20path.\x20\n\r\n\x05\x04\t\x02\x04\x04\x12\x04\xd7\x01\x08\x10\n\r\n\
    \x05\x04\t\x02\x04\x05\x12\x04\xd7\x01\x11\x17\n\r\n\x05\x04\t\x02\x04\
    \x01\x12\x04\xd7\x01\x18$\n\r\n\x05\x04\t\x02\x04\x03\x12\x04\xd7\x01'(\
    \n\x0c\n\x04\x04\t\x02\x05\x12\x04\xd9\x01\x085\n\r\n\x05\x04\t\x02\x05\
    \x04\x12\x04\xd9\x01\x08\x10\n\r\n\x05\x04\t\x02\x05\x05\x12\x04\xd9\x01\
    \x11\x15\n\r\n\x05\x04\t\x02\x05\x01\x12\x04\xd9\x01\x16\x1e\n\r\n\x05\
    \x04\t\x02\x05\x03\x12\x04\xd9\x01!\"\n\r\n\x05\x04\t\x02\x05\x08\x12\
    \x04\xd9\x01#4\n\r\n\x05\x04\t\x02\x05\x07\x12\x04\xd9\x01.3\n\x0c\n\x04\
    \x04\t\x02\x06\x12\x04\xda\x01\x083\n\r\n\x05\x04\t\x02\x06\x04\x12\x04\
    \xda\x01\x08\x10\n\r\n\x05\x04\t\x02\x06\x05\x12\x04\xda\x01\x11\x15\n\r\
    \n\x05\x04\t\x02\x06\x01\x12\x04\xda\x01\x16\x1c\n\r\n\x05\x04\t\x02\x06\
    \x03\x12\x04\xda\x01\x1f\x20\n\r\n\x05\x04\t\x02\x06\x08\x12\x04\xda\x01\
    !2\n\r\n\x05\x04\t\x02\x06\x07\x12\x04\xda\x01,1\nK\n\x02\x04\n\x12\x06\
    \xdf\x01\0\xf9\x01\x01\x1a=\x20copies\x20of\x20some\x20prototype\x20mode\
    l,\x20possibly\x20rotated\x20and\x20scaled\x20\n\x0b\n\x03\x04\n\x01\x12\
    \x04\xdf\x01\x08\x18\n\x91\x01\n\x04\x04\n\x02\0\x12\x04\xe3\x01\x08\"\
    \x1a\x82\x01\x20the\x20prototype\x20model,\x20referencing\x20the\x20mode\
    lBlock.\nAlternatively,\x20an\x20external\x20resource\x20can\x20be\x20re\
    ferenced\x20using\x20resourceIdentifier.\x20\n\r\n\x05\x04\n\x02\0\x04\
    \x12\x04\xe3\x01\x08\x10\n\r\n\x05\x04\n\x02\0\x05\x12\x04\xe3\x01\x11\
    \x17\n\r\n\x05\x04\n\x02\0\x01\x12\x04\xe3\x01\x18\x1d\n\r\n\x05\x04\n\
    \x02\0\x03\x12\x04\xe3\x01\x20!\n\xc7\x01\n\x04\x04\n\x02\x01\x12\x04\
    \xe7\x01\x08/\x1a\xb8\x01\x20string\x20identifying\x20an\x20external\x20\
    model\x20in\x20some\x20way,\x20e.g.\x20as\x20an\x20URI\x20or\x20a\x20str\
    ing\x20constant.\nAlternatively,\x20a\x20prototype\x20model\x20included\
    \x20in\x20this\x20file\x20can\x20be\x20referenced\x20using\x20the\x20mod\
    el\x20field.\x20\n\r\n\x05\x04\n\x02\x01\x04\x12\x04\xe7\x01\x08\x10\n\r\
    \n\x05\x04\n\x02\x01\x05\x12\x04\xe7\x01\x11\x17\n\r\n\x05\x04\n\x02\x01\
    \x01\x12\x04\xe7\x01\x18*\n\r\n\x05\x04\n\x02\x01\x03\x12\x04\xe7\x01-.\
    \n\xbb\x01\n\x04\x04\n\x02\x02\x12\x04\xec\x01\x083\x1a\xac\x01\x20posit\
    ion\x20of\x20each\x20instance.\nValues\x20are\x20in\x20millimeters\x20re\
    lative\x20to\x20the\x20center\x20of\x20the\x20tile\x20(like\x20Vector3dB\
    lock).\nEach\x20position\x20is\x20represented\x20as\x20an\x20x,\x20y,\
    \x20z\x20triple\x20of\x20values.\x20\n\r\n\x05\x04\n\x02\x02\x04\x12\x04\
    \xec\x01\x08\x10\n\r\n\x05\x04\n\x02\x02\x05\x12\x04\xec\x01\x11\x17\n\r\
    \n\x05\x04\n\x02\x02\x01\x12\x04\xec\x01\x18\x20\n\r\n\x05\x04\n\x02\x02\
    \x03\x12\x04\xec\x01#$\n\r\n\x05\x04\n\x02\x02\x08\x12\x04\xec\x01%2\n\
    \x0e\n\x06\x04\n\x02\x02\x08\x02\x12\x04\xec\x01&1\n\xab\x01\n\x04\x04\n\
    \x02\x03\x12\x04\xf0\x01\x083\x1a\x9c\x01\x20rotation\x20angle\x20around\
    \x20the\x20y\x20axis\x20for\x20each\x20instance\x20in\x20milliradians,\
    \x20clockwise.\nEither\x20one\x20third\x20of\x20the\x20length\x20of\x20'\
    position'\x20or\x20empty\x20(for\x20a\x20default\x20of\x200).\x20\n\r\n\
    \x05\x04\n\x02\x03\x04\x12\x04\xf0\x01\x08\x10\n\r\n\x05\x04\n\x02\x03\
    \x05\x12\x04\xf0\x01\x11\x16\n\r\n\x05\x04\n\x02\x03\x01\x12\x04\xf0\x01\
    \x17\x20\n\r\n\x05\x04\n\x02\x03\x03\x12\x04\xf0\x01#$\n\r\n\x05\x04\n\
    \x02\x03\x08\x12\x04\xf0\x01%2\n\x0e\n\x06\x04\n\x02\x03\x08\x02\x12\x04\
    \xf0\x01&1\n\x85\x01\n\x04\x04\n\x02\x04\x12\x04\xf4\x01\x080\x1aw\x20sc\
    ale\x20factor\x20for\x20each\x20instance\x20in\x201/1000.\nEither\x20one\
    \x20third\x20of\x20the\x20length\x20of\x20'position'\x20or\x20empty\x20(\
    for\x20a\x20default\x20of\x201).\x20\n\r\n\x05\x04\n\x02\x04\x04\x12\x04\
    \xf4\x01\x08\x10\n\r\n\x05\x04\n\x02\x04\x05\x12\x04\xf4\x01\x11\x17\n\r\
    \n\x05\x04\n\x02\x04\x01\x12\x04\xf4\x01\x18\x1d\n\r\n\x05\x04\n\x02\x04\
    \x03\x12\x04\xf4\x01\x20!\n\r\n\x05\x04\n\x02\x04\x08\x12\x04\xf4\x01\"/\
    \n\x0e\n\x06\x04\n\x02\x04\x08\x02\x12\x04\xf4\x01#.\nD\n\x04\x04\n\x02\
    \x05\x12\x04\xf7\x01\x08)\x1a6\x20this\x20message\x20is\x20present\x20if\
    \x20this\x20geometry\x20is\x20animated\x20\n\r\n\x05\x04\n\x02\x05\x04\
    \x12\x04\xf7\x01\x08\x10\n\r\n\x05\x04\n\x02\x05\x06\x12\x04\xf7\x01\x11\
    \x1a\n\r\n\x05\x04\n\x02\x05\x01\x12\x04\xf7\x01\x1b$\n\r\n\x05\x04\n\
    \x02\x05\x03\x12\x04\xf7\x01'(\n\xfa\x01\n\x02\x04\x0b\x12\x06\xff\x01\0\
    \xa7\x02\x01\x1a\xeb\x01\x20The\x20parameters\x20defining\x20an\x20anima\
    tion.\nAt\x20the\x20moment,\x20this\x20does\x20not\x20support\x20keys\
    \x20yet.\nInstead,\x20there's\x20an\x20assumption\x20based\x20on\x20the\
    \x20type\x20of\x20animation,\ne.g.\x20rotations\x20assume\x20that\x20eac\
    h\x20run\x20of\x20the\x20animation\x20means\x20one\x20full\x20(360\xc2\
    \xb0)\x20rotation.\x20\n\x0b\n\x03\x04\x0b\x01\x12\x04\xff\x01\x08\x11\n\
    5\n\x04\x04\x0b\x04\0\x12\x06\x82\x02\x08\x88\x02\t\x1a%\x20the\x20prope\
    rty\x20that\x20is\x20being\x20modified\x20\n\r\n\x05\x04\x0b\x04\0\x01\
    \x12\x04\x82\x02\r\x1a\n|\n\x06\x04\x0b\x04\0\x02\0\x12\x04\x86\x02\x10\
    \x1f\x1al\x20clockwise\x20rotation\x20around\x20the\x20model's\x20local\
    \x20x\x20axis\n(before\x20InstanceGeometry's\x20transformations\x20are\
    \x20applied)\x20\n\x0f\n\x07\x04\x0b\x04\0\x02\0\x01\x12\x04\x86\x02\x10\
    \x1a\n\x0f\n\x07\x04\x0b\x04\0\x02\0\x02\x12\x04\x86\x02\x1d\x1e\n<\n\
    \x04\x04\x0b\x04\x01\x12\x06\x8b\x02\x08\x91\x02\t\x1a,\x20what\x20happe\
    ns\x20after\x20the\x20animation\x20completes\x20\n\r\n\x05\x04\x0b\x04\
    \x01\x01\x12\x04\x8b\x02\r\x15\n\x89\x01\n\x06\x04\x0b\x04\x01\x02\0\x12\
    \x04\x8f\x02\x10\x1a\x1ay\x20restart\x20the\x20animation\x20from\x20the\
    \x20beginning.\nRemaining\x20progress\x20should\x20be\x20used\x20in\x20t\
    he\x20next\x20cycle\x20(i.e.\x20modulo-style\x20wrap).\x20\n\x0f\n\x07\
    \x04\x0b\x04\x01\x02\0\x01\x12\x04\x8f\x02\x10\x15\n\x0f\n\x07\x04\x0b\
    \x04\x01\x02\0\x02\x12\x04\x8f\x02\x18\x19\n\xce\x01\n\x04\x04\x0b\x04\
    \x02\x12\x06\x96\x02\x08\x9c\x02\t\x1a\xbd\x01\x20the\x20source\x20of\
    \x20the\x20animation\x20timer.\nMay\x20eventually\x20be\x20extended\x20t\
    o\x20include\x20local\x20time\x20in\x20the\x20simulated\x20location,\nan\
    imations\x20triggered\x20by\x20user\x20interaction,\x20or\x20factors\x20\
    such\x20as\x20wind\x20direction.\x20\n\r\n\x05\x04\x0b\x04\x02\x01\x12\
    \x04\x96\x02\r\x16\n\xa5\x01\n\x06\x04\x0b\x04\x02\x02\0\x12\x04\x9a\x02\
    \x10\x1f\x1a\x94\x01\x20A\x20clock\x20counting\x20seconds\x20with\x20arb\
    itrary\x20starting\x20point.\nCan\x20even\x20be\x20started\x20at\x20diff\
    erent\x20values\x20for\x20different\x20models\x20to\x20prevent\x20synced\
    \x20animations.\x20\n\x0f\n\x07\x04\x0b\x04\x02\x02\0\x01\x12\x04\x9a\
    \x02\x10\x1a\n\x0f\n\x07\x04\x0b\x04\x02\x02\0\x02\x12\x04\x9a\x02\x1d\
    \x1e\n\x0c\n\x04\x04\x0b\x02\0\x12\x04\x9e\x02\x08(\n\r\n\x05\x04\x0b\
    \x02\0\x04\x12\x04\x9e\x02\x08\x10\n\r\n\x05\x04\x0b\x02\0\x06\x12\x04\
    \x9e\x02\x11\x1e\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\x9e\x02\x1f#\n\r\n\
    \x05\x04\x0b\x02\0\x03\x12\x04\x9e\x02&'\n\x0c\n\x04\x04\x0b\x02\x01\x12\
    \x04\xa0\x02\x089\n\r\n\x05\x04\x0b\x02\x01\x04\x12\x04\xa0\x02\x08\x10\
    \n\r\n\x05\x04\x0b\x02\x01\x06\x12\x04\xa0\x02\x11\x19\n\r\n\x05\x04\x0b\
    \x02\x01\x01\x12\x04\xa0\x02\x1a\"\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\
    \xa0\x02%&\n\r\n\x05\x04\x0b\x02\x01\x08\x12\x04\xa0\x02'8\n\r\n\x05\x04\
    \x0b\x02\x01\x07\x12\x04\xa0\x0227\n\x0c\n\x04\x04\x0b\x02\x02\x12\x04\
    \xa2\x02\x08@\n\r\n\x05\x04\x0b\x02\x02\x04\x12\x04\xa2\x02\x08\x10\n\r\
    \n\x05\x04\x0b\x02\x02\x06\x12\x04\xa2\x02\x11\x1a\n\r\n\x05\x04\x0b\x02\
    \x02\x01\x12\x04\xa2\x02\x1b$\n\r\n\x05\x04\x0b\x02\x02\x03\x12\x04\xa2\
    \x02'(\n\r\n\x05\x04\x0b\x02\x02\x08\x12\x04\xa2\x02)?\n\r\n\x05\x04\x0b\
    \x02\x02\x07\x12\x04\xa2\x024>\nS\n\x04\x04\x0b\x02\x03\x12\x04\xa5\x02\
    \x08*\x1aE\x20the\x20fraction\x20of\x20the\x20entire\x20animation\x20tha\
    t\x20is\x20completed\x20each\x20second.\x20\n\r\n\x05\x04\x0b\x02\x03\
    \x04\x12\x04\xa5\x02\x08\x10\n\r\n\x05\x04\x0b\x02\x03\x05\x12\x04\xa5\
    \x02\x11\x17\n\r\n\x05\x04\x0b\x02\x03\x01\x12\x04\xa5\x02\x18%\n\r\n\
    \x05\x04\x0b\x02\x03\x03\x12\x04\xa5\x02()\n*\n\x02\x04\x0c\x12\x06\xaa\
    \x02\0\xc1\x02\x01\x1a\x1c\x20a\x20three-dimensional\x20object\x20\n\x0b\
    \n\x03\x04\x0c\x01\x12\x04\xaa\x02\x08\x13\nU\n\x04\x04\x0c\x02\0\x12\
    \x04\xad\x02\x08\"\x1aG\x20the\x20OSM\x20id\x20of\x20the\x20primary\x20e\
    lement\x20this\x20object\x20is\x20created\x20from,\x20if\x20any\x20\n\r\
    \n\x05\x04\x0c\x02\0\x04\x12\x04\xad\x02\x08\x10\n\r\n\x05\x04\x0c\x02\0\
    \x05\x12\x04\xad\x02\x11\x17\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\xad\x02\
    \x18\x1d\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\xad\x02\x20!\nU\n\x04\x04\
    \x0c\x02\x01\x12\x04\xb0\x02\x08%\x1aG\x20the\x20type\x20of\x20this\x20W\
    orldObject,\x20in\x20broad\x20terms.\x20References\x20stringBlock.\x20\n\
    \r\n\x05\x04\x0c\x02\x01\x04\x12\x04\xb0\x02\x08\x10\n\r\n\x05\x04\x0c\
    \x02\x01\x05\x12\x04\xb0\x02\x11\x17\n\r\n\x05\x04\x0c\x02\x01\x01\x12\
    \x04\xb0\x02\x18\x20\n\r\n\x05\x04\x0c\x02\x01\x03\x12\x04\xb0\x02#$\nv\
    \n\x04\x04\x0c\x02\x02\x12\x04\xb3\x02\x089\x1ah\x20geometry\x20this\x20\
    object\x20is\x20composed\x20of;\x20at\x20least\x201\x20of\x20this\x20or\
    \x20one\x20of\x20the\x20other\x20geometry\x20types\x20is\x20required\x20\
    \n\r\n\x05\x04\x0c\x02\x02\x04\x12\x04\xb3\x02\x08\x10\n\r\n\x05\x04\x0c\
    \x02\x02\x06\x12\x04\xb3\x02\x11!\n\r\n\x05\x04\x0c\x02\x02\x01\x12\x04\
    \xb3\x02\"4\n\r\n\x05\x04\x0c\x02\x02\x03\x12\x04\xb3\x0278\nv\n\x04\x04\
    \x0c\x02\x03\x12\x04\xb6\x02\x08;\x1ah\x20geometry\x20this\x20object\x20\
    is\x20composed\x20of;\x20at\x20least\x201\x20of\x20this\x20or\x20one\x20\
    of\x20the\x20other\x20geometry\x20types\x20is\x20required\x20\n\r\n\x05\
    \x04\x0c\x02\x03\x04\x12\x04\xb6\x02\x08\x10\n\r\n\x05\x04\x0c\x02\x03\
    \x06\x12\x04\xb6\x02\x11\"\n\r\n\x05\x04\x0c\x02\x03\x01\x12\x04\xb6\x02\
    #6\n\r\n\x05\x04\x0c\x02\x03\x03\x12\x04\xb6\x029:\nv\n\x04\x04\x0c\x02\
    \x04\x12\x04\xb9\x02\x089\x1ah\x20geometry\x20this\x20object\x20is\x20co\
    mposed\x20of;\x20at\x20least\x201\x20of\x20this\x20or\x20one\x20of\x20th\
    e\x20other\x20geometry\x20types\x20is\x20required\x20\n\r\n\x05\x04\x0c\
    \x02\x04\x04\x12\x04\xb9\x02\x08\x10\n\r\n\x05\x04\x0c\x02\x04\x06\x12\
    \x04\xb9\x02\x11!\n\r\n\x05\x04\x0c\x02\x04\x01\x12\x04\xb9\x02\"4\n\r\n\
    \x05\x04\x0c\x02\x04\x03\x12\x04\xb9\x0278\ng\n\x04\x04\x0c\x02\x05\x12\
    \x04\xbc\x02\x081\x1aY*\x20defines\x20a\x20level\x20of\x20detail\x20(0\
    \x20to\x204)\x20as\x20the\x20lower\x20end\x20of\x20the\x20range\x20where\
    \x20this\x20is\x20visible\x20\n\r\n\x05\x04\x0c\x02\x05\x04\x12\x04\xbc\
    \x02\x08\x10\n\r\n\x05\x04\x0c\x02\x05\x05\x12\x04\xbc\x02\x11\x17\n\r\n\
    \x05\x04\x0c\x02\x05\x01\x12\x04\xbc\x02\x18\x1e\n\r\n\x05\x04\x0c\x02\
    \x05\x03\x12\x04\xbc\x02!\"\n\r\n\x05\x04\x0c\x02\x05\x08\x12\x04\xbc\
    \x02#0\n\r\n\x05\x04\x0c\x02\x05\x07\x12\x04\xbc\x02./\ng\n\x04\x04\x0c\
    \x02\x06\x12\x04\xbf\x02\x081\x1aY*\x20defines\x20a\x20level\x20of\x20de\
    tail\x20(0\x20to\x204)\x20as\x20the\x20upper\x20end\x20of\x20the\x20rang\
    e\x20where\x20this\x20is\x20visible\x20\n\r\n\x05\x04\x0c\x02\x06\x04\
    \x12\x04\xbf\x02\x08\x10\n\r\n\x05\x04\x0c\x02\x06\x05\x12\x04\xbf\x02\
    \x11\x17\n\r\n\x05\x04\x0c\x02\x06\x01\x12\x04\xbf\x02\x18\x1e\n\r\n\x05\
    \x04\x0c\x02\x06\x03\x12\x04\xbf\x02!\"\n\r\n\x05\x04\x0c\x02\x06\x08\
    \x12\x04\xbf\x02#0\n\r\n\x05\x04\x0c\x02\x06\x07\x12\x04\xbf\x02./\n#\n\
    \x02\x04\r\x12\x06\xc4\x02\0\xcf\x02\x01\x1a\x15\x20a\x20tile\x20with\
    \x203d\x20data\x20\n\x0b\n\x03\x04\r\x01\x12\x04\xc4\x02\x08\x0c\n\x0c\n\
    \x04\x04\r\x02\0\x12\x04\xc6\x02\x081\n\r\n\x05\x04\r\x02\0\x04\x12\x04\
    \xc6\x02\x08\x10\n\r\n\x05\x04\r\x02\0\x06\x12\x04\xc6\x02\x11\x1e\n\r\n\
    \x05\x04\r\x02\0\x01\x12\x04\xc6\x02\x1f,\n\r\n\x05\x04\r\x02\0\x03\x12\
    \x04\xc6\x02/0\n\x0c\n\x04\x04\r\x02\x01\x12\x04\xc7\x02\x081\n\r\n\x05\
    \x04\r\x02\x01\x04\x12\x04\xc7\x02\x08\x10\n\r\n\x05\x04\r\x02\x01\x06\
    \x12\x04\xc7\x02\x11\x1e\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\xc7\x02\x1f\
    ,\n\r\n\x05\x04\r\x02\x01\x03\x12\x04\xc7\x02/0\n\x0c\n\x04\x04\r\x02\
    \x02\x12\x04\xc8\x02\x08-\n\r\n\x05\x04\r\x02\x02\x04\x12\x04\xc8\x02\
    \x08\x10\n\r\n\x05\x04\r\x02\x02\x06\x12\x04\xc8\x02\x11\x1c\n\r\n\x05\
    \x04\r\x02\x02\x01\x12\x04\xc8\x02\x1d(\n\r\n\x05\x04\r\x02\x02\x03\x12\
    \x04\xc8\x02+,\n\x0c\n\x04\x04\r\x02\x03\x12\x04\xc9\x02\x08+\n\r\n\x05\
    \x04\r\x02\x03\x04\x12\x04\xc9\x02\x08\x10\n\r\n\x05\x04\r\x02\x03\x06\
    \x12\x04\xc9\x02\x11\x1b\n\r\n\x05\x04\r\x02\x03\x01\x12\x04\xc9\x02\x1c\
    &\n\r\n\x05\x04\r\x02\x03\x03\x12\x04\xc9\x02)*\n\x0c\n\x04\x04\r\x02\
    \x04\x12\x04\xca\x02\x081\n\r\n\x05\x04\r\x02\x04\x04\x12\x04\xca\x02\
    \x08\x10\n\r\n\x05\x04\r\x02\x04\x06\x12\x04\xca\x02\x11\x1e\n\r\n\x05\
    \x04\r\x02\x04\x01\x12\x04\xca\x02\x1f,\n\r\n\x05\x04\r\x02\x04\x03\x12\
    \x04\xca\x02/0\n\x0c\n\x04\x04\r\x02\x05\x12\x04\xcb\x02\x08+\n\r\n\x05\
    \x04\r\x02\x05\x04\x12\x04\xcb\x02\x08\x10\n\r\n\x05\x04\r\x02\x05\x06\
    \x12\x04\xcb\x02\x11\x1b\n\r\n\x05\x04\r\x02\x05\x01\x12\x04\xcb\x02\x1c\
    &\n\r\n\x05\x04\r\x02\x05\x03\x12\x04\xcb\x02)*\n\x0c\n\x04\x04\r\x02\
    \x06\x12\x04\xcd\x02\x08)\n\r\n\x05\x04\r\x02\x06\x04\x12\x04\xcd\x02\
    \x08\x10\n\r\n\x05\x04\r\x02\x06\x06\x12\x04\xcd\x02\x11\x1c\n\r\n\x05\
    \x04\r\x02\x06\x01\x12\x04\xcd\x02\x1d$\n\r\n\x05\x04\r\x02\x06\x03\x12\
    \x04\xcd\x02'(\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
